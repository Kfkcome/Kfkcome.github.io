<!DOCTYPE html><html lang="zh-Hans">
  <head><!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-LVD2CPW3EW"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'G-LVD2CPW3EW');
		
	</script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>计算机网络笔记 - Ennis's Blog</title>

<meta name="description" content="计算机网络笔记第一章计算机网络与因特网1. 什么是因特网——因特网的构成越来越多的非传统因特网“物品”（便携机、游戏机、平板电脑、电视、游戏机）等正在与因特网相连，所有这些设备都叫主机或者端系统  构成：      端系统通过通信链路和分组交换机连接在一起    分组交换机从它的一条入通信链路接受到达的分组，并从...">
<link rel="canonical" href="/2023/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0.html"><link rel="alternate" type="application/rss+xml" title="Ennis's Blog" href="/feed.xml"><!-- start favicons snippet, use https://realfavicongenerator.net/ --><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png"><link rel="manifest" href="/assets/site.webmanifest"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#fc4d50"><link rel="shortcut icon" href="/assets/favicon.ico">

<meta name="msapplication-TileColor" content="#ffc40d"><meta name="msapplication-config" content="/assets/browserconfig.xml">

<meta name="theme-color" content="#ffffff">
<!-- end favicons snippet --><link rel="stylesheet" href="/assets/css/main.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.css" ><!-- start custom head snippets -->

<!-- end custom head snippets -->
<script>(function() {
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };

  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  };

  window.isOverallScroller = function(node) {
    return node === document.documentElement || node === document.body || node === window;
  };

  window.isFormElement = function(node) {
    var tagName = node.tagName;
    return tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
  };

  window.pageLoad = (function () {
    var loaded = false, cbs = [];
    window.addEventListener('load', function () {
      var i;
      loaded = true;
      if (cbs.length > 0) {
        for (i = 0; i < cbs.length; i++) {
          cbs[i]();
        }
      }
    });
    return {
      then: function(cb) {
        cb && (loaded ? cb() : (cbs.push(cb)));
      }
    };
  })();
})();
(function() {
  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };
})();
(function() {
  var Set = (function() {
    var add = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (data[i] === item) {
          return;
        }
      }
      this.size ++;
      data.push(item);
      return data;
    };

    var Set = function(data) {
      this.size = 0;
      this._data = [];
      var i;
      if (data.length > 0) {
        for (i = 0; i < data.length; i++) {
          add.call(this, data[i]);
        }
      }
    };
    Set.prototype.add = add;
    Set.prototype.get = function(index) { return this._data[index]; };
    Set.prototype.has = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (this.get(i) === item) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.is = function(map) {
      if (map._data.length !== this._data.length) { return false; }
      var i, j, flag, tData = this._data, mData = map._data;
      for (i = 0; i < tData.length; i++) {
        for (flag = false, j = 0; j < mData.length; j++) {
          if (tData[i] === mData[j]) {
            flag = true;
            break;
          }
        }
        if (!flag) { return false; }
      }
      return true;
    };
    Set.prototype.values = function() {
      return this._data;
    };
    return Set;
  })();

  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    };
    var end = function(type, url) {
      var s, q, qi, cbs, i, j, cur, val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j];
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, q, qi, node, i, cur,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  };
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);
})();
</script><script>
  (function() {
    var TEXT_VARIABLES = {
      version: '2.2.6',
      sources: {
        font_awesome: 'https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.css',
        jquery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
        leancloud_js_sdk: '//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js',
        chart: 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js',
        gitalk: {
          js: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.js',
          css: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.css'
        },
        valine: 'https://unpkg.com/valine/dist/Valine.min.js',
        mathjax: 'https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML',
        mermaid: 'https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js'
      },
      site: {
        toc: {
          selectors: 'h1,h2,h3'
        }
      },
      paths: {
        search_js: '/assets/search.js'
      }
    };
    window.TEXT_VARIABLES = TEXT_VARIABLES;
  })();
</script>
</head>
  <body>
    <div class="root" data-is-touch="false">
      <div class="layout--page js-page-root"><div class="page__main js-page-main page__main--immersive page__viewport has-aside cell cell--auto">

      <div class="page__main-inner"><div class="page__header d-print-none"><header class="header"><div class="main">
      <div class="header__title">
        <div class="header__brand"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="24px" height="24px" viewBox="0 0 24 24">
<style type="text/css">
	.st0{fill:#515151;}
</style>
<path class="st0" d="M1.7,22.3c5.7-5.7,11.3-5.7,17,0c3.3-3.3,3.5-5.3,0.8-6c2.7,0.7,3.5-1.1,2.3-5.6s-3.3-5.2-6.3-2.1
	c3-3,2.3-5.2-2.1-6.3S7,1.8,7.7,4.6C7,1.8,5,2.1,1.7,5.3C7.3,11,7.3,16.7,1.7,22.3"/>
</svg>
<a title="Willing to be a question, willing to be an answer.
" href="/">Ennis's Blog</a></div><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></div><nav class="navigation">
        <ul><li class="navigation__item"><a href="/">主页</a></li><li class="navigation__item"><a href="/archive.html">归档</a></li><li class="navigation__item"><a href="/about.html">关于</a></li><li><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></li></ul>
      </nav></div>
  </header>
</div><div class="page__content"><div class="article__header--overlay"><div class="hero overlay" style="background-image:;background-color:#f1f8ff;"><div class="hero__content"><div class ="main"><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a>
            </li><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0">课程笔记</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>2023年 12月05日</span>
            </li><li><i class="far fa-eye"></i> <span class="js-pageview" data-page-key="post24">0</span> 阅读</li></ul></div><div class="article__header"><header><h1>计算机网络笔记</h1></header><span class="split-space">&nbsp;</span>
          <a class="edit-on-github"
            title="在 Github 上修改"
            href="https://github.com/Kfkcome/Kfkcome.github.io/tree/master/_posts/2023-12-5-计算机网络笔记.md">
            <i class="far fa-edit"></i></a></div><p class="overlay__excerpt">计算机网络笔记第一章计算机网络与因特网1. 什么是因特网——因特网的构成越来越多的非传统因特网“物品”（便携机、游戏机、平板电脑、电视、游戏机）等正在与因特网相连，所有这些设备都叫主机或者端系统  构成：      端系统通过通信链路和分组交换机连接在一起    分组交换机从它的一条入通信链路接受到达的分组，并从它的一条出通信链路转发该分组。    分组交换机：路由器（router）、链路交...</p></div></div>
              </div>
            </div><div class ="main"><div class="grid grid--reverse">

              <div class="col-aside d-print-none js-col-aside"><aside class="page__aside js-page-aside"><div class="toc-aside js-toc-root"></div>
</aside></div>

              <div class="col-main cell cell--auto"><!-- start custom main top snippet -->

<!-- end custom main top snippet -->
<article itemscope itemtype="http://schema.org/Article"><meta itemprop="headline" content="计算机网络笔记"><meta itemprop="author" content="Xingjie Gao"/><meta itemprop="datePublished" content="2023-12-05T00:00:00+08:00">
    <meta itemprop="keywords" content="计算机网络,课程笔记"><div class="js-article-content"><div class="layout--article"><!-- start custom article top snippet -->

<!-- end custom article top snippet -->
<div class="article__content" itemprop="articleBody"><h1 id="计算机网络笔记">计算机网络笔记</h1>

<h2 id="第一章计算机网络与因特网">第一章计算机网络与因特网</h2>

<h3 id="1-什么是因特网因特网的构成">1. 什么是因特网——因特网的构成</h3>

<p>越来越多的非传统因特网“物品”（便携机、游戏机、平板电脑、电视、游戏机）等正在与因特网相连，所有这些设备都叫<strong>主机或者端系统</strong></p>

<blockquote>
  <p>构成：</p>

  <ol>
    <li>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接在一起</li>
    <li>分组交换机从它的一条<strong>入通信链路</strong>接受到达的分组，并从它的一条<strong>出通信链路</strong>转发该分组。</li>
    <li>分组交换机：<strong>路由器（router）</strong>、<strong>链路交换机（link-layer switch）</strong>。
      <ol>
        <li>相同点：两种交换机朝着最后总目的地转发分组。</li>
        <li>不同点：链路层交换机通常用于接入网中，而路由器通常用于网络核心中。
<!---more--></li>
      </ol>
    </li>
    <li>
      <p>一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<strong>路径（route  或 path）</strong></p>
    </li>
    <li>
      <p>端系统通过<strong>因特网服务提供商（Internet Service Provide, ISP)</strong>接入因特网，每一个 ISP 自身就是一个由多台分组交换机和多段链路组成的网络。<strong>因特网就是将端系统彼此互联，所以为端系统提供接入的 ISP 也必须互联</strong>。ISP 从低层到高层，互连起来。特点：1.  每一层都是独立管理的 2. 服从 IP 协议 3. 遵循一定命名和地址规则</p>
    </li>
    <li>
      <p>端系统、分组交换机和其他因特网部件都要运行一系列的<strong>协议</strong>，<strong>这些协议控制着因特网中公的信息的接受和发送</strong>。</p>

      <ol>
        <li><strong>TCP（Transmission Control Protocol 传输控制协议）</strong></li>
        <li><strong>IP（Internet Protocol 网际协议)</strong> ：定义了在路由器和端系统之间的发送和接受的分组格式</li>
      </ol>

      <p>因特网的主要协议统称为<strong>TCP/IP</strong></p>
    </li>
  </ol>
</blockquote>

<h3 id="2-什么是因特网因特网的服务">2. 什么是因特网——因特网的服务</h3>

<p>分布式应用程序（distributed application)</p>

<p>运行在一个端系统上的应用程序怎样才能指令互联网向运行在另一个端系统的的软件发送软件呢？</p>

<blockquote>
  <p>与互联网相连的端系统提供了一个<strong>套接字接口（socktet interface）</strong>，该接口规定了运行在端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定的目的地程序交付数据的方式</p>

  <p><strong>因特网套接字接口是一套发送程序必须遵循的规则集合</strong></p>
</blockquote>

<h3 id="3-什么是网络协议">3. 什么是网络协议</h3>

<p><strong>协议（protocol)</strong>：定义了两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和接受一条报文或其他事件所采取的动作。</p>

<h3 id="网络边缘">网络边缘</h3>

<h4 id="一些概念">一些概念</h4>

<p>端系统之所以叫端系统是因为它们位于因特网的边缘。</p>

<p>因特网的端系统包括：桌面计算机，服务器和移动计算机，以及一些非正统物品作为端系统与因特网相连。</p>

<p>端系统被称为<strong>主机（host)</strong>, 主机=端系统</p>

<p>主机有时又被划分为：<strong>客户（client）</strong> 和 <strong>服务器（server）</strong>（所以服务器也是位于因特网的边缘的）</p>

<h4 id="接入网">接入网</h4>

<p>接入网是指将端系统<strong>物理连接</strong>到其边缘路由器的网络
边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器</p>
<h5 id="接入网的方式">接入网的方式</h5>

<ol>
  <li>宽带住宅接入方式：<strong>数字用户线（digital Subscriber Line, DSL)</strong>，电缆，光纤到户（Fiber To The Home, FTTH)(多户共享一个光纤，光纤分布体系结构：有源光纤网络 (Active Opitcal Network)、无源光纤网络（Passive Optical Network, PON)</li>
  <li>企业接入：以太网和 WIFI
    <ol>
      <li>使用<strong>局域网（LAN）</strong> 将端系统连接到边缘路由器</li>
      <li>具体过程：无线用户-&gt;接入点-&gt;企业网（有线以太网）</li>
      <li>基于 IEEE 802.11 技术的无线 LAN 接入俗称 WiFi</li>
    </ol>
  </li>
  <li>广域网无线接入：3 G 和 LTE
    <h5 id="物理媒体">物理媒体</h5>
    <p>物理媒体分为：<strong>导引型媒体</strong>、<strong>非导引型媒体</strong></p>
  </li>
  <li>导引型媒体：电波沿着固体媒体前行，如光缆、双绞铜或同轴电缆</li>
  <li>非导引型媒体：电波在空气或外层空间中传播，如无线局域网或数字卫星频道
具体的物理媒体：</li>
  <li>双铜绞线</li>
  <li>同轴电缆</li>
  <li>光纤</li>
  <li>陆地无线电信道</li>
  <li>卫星无线电信道
    <h3 id="网络核心">网络核心</h3>
  </li>
</ol>

<p>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换</strong>(circuit switching ) 和<strong>分组交换</strong>(packet switching )</p>

<h4 id="数据交换方式-分组交换">数据交换方式 ——分组交换</h4>

<p>主机将应用报文分解成数据包——分组交换，</p>

<p><strong>大致过程</strong> ：数据包从一个路由器转发到下一个路由器跨越从源到目的地上路径上的链路。</p>

<p><strong>特点：</strong></p>

<ol>
  <li>存储转发：整个包必须到达路由器，然后才能在下一个链路上传输</li>
  <li>在发送端先把报文划分成较短的、固定长度的数据段</li>
</ol>

<p>具体过程：</p>

<ol>
  <li>
    <p><strong>每个数据段前添加上首部构成分组（packet）</strong></p>

    <p><strong>示意图：</strong><img src="/assets/计算机网络.assets/image-20230921150259626.png" alt="image-20230921150259626" /></p>
  </li>
  <li>
    <p><strong>分组交换的传输的单元</strong></p>
    <ul>
      <li>分组交换的网以分组交换作为基本的数据传输单元</li>
      <li>依次把各分组发送的到接收端</li>
    </ul>
  </li>
</ol>

<p>​	示意图：<img src="/assets/计算机网络.assets/image-20230921151157239.png" alt="image-20230921151157239" /></p>

<ol>
  <li><strong>收到分组后剥去首部还原成报文</strong></li>
  <li>最后在接收端把收到的<strong>数据恢复成原来的报文</strong>
    <h5 id="分组交换的一些规则">分组交换的一些规则</h5>
    <ul>
      <li><strong>每一个</strong>分组的首部含有<strong>地址</strong>（如目的地址和源地址）等控制信息</li>
      <li>分组交换网中的节点交换机根据收到的分组首部中的<strong>地址信息</strong>，把分组<strong>转发</strong>到下一个节点交换机</li>
      <li>每个分组在互联网中独立的选择传输路径</li>
      <li>用这样的<strong>存储转发</strong>方式，最后分组就能到达最终<strong>目的地</strong></li>
      <li>如果某源端系统或分组交换机经过一条链路发送一个 L 比特的分组，链路的传输速率为 R 比特每秒，则传输该分组的时间是 $\huge \frac{L}{R}$ 秒
        <h5 id="存储转发传输">存储转发传输</h5>
        <p>存储转发传输是<strong>指在交换机能够开始向输出链路传输该分组的第一个 bit 之前，必须接收到整个分组。</strong>
多数分组交换机在链路的输入端使用<strong>存储转发传输（store-and-forward transmission)</strong>
每台分组交换机有多条链路与之相连，对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>（output buffer 也称为<strong>输出队列</strong>output queue)，<strong>如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。</strong></p>
      </li>
    </ul>
  </li>
</ol>

<p>缓存空间有限容易导致<strong>分组丢失（丢包）</strong>（packet loss)</p>
<h6 id="转发表和路由选择协议">转发表和路由选择协议</h6>
<p>每台路由器具有一个<strong>转发表（forward table)</strong> 用于将目的地址（或目的地址的一部分）映射成输出链路。
<strong>路由选择协议</strong>：因特网具有一些特殊的路由选择协议（routing protocol )用于自动的设置这些转发表。</p>

<h5 id="时延">时延</h5>
<ol>
  <li>节点处理时延（nodal processing delay)</li>
  <li>排队时延 (queuing delay )</li>
  <li>传输时延 (transmission  delay)</li>
  <li>传播时延 (propagation delay)
这些时延的总体累加起来是<strong>节点总时延（total nodal  delay)</strong>
（1）处理时延
检查分组首部和决定该分组导向何处做需要的时间是<strong>处理时延</strong>的一部分，除此之外还有检查差错
（2）排队时延
在队列中，当分组在链路上等待传输时，它经受的<strong>排队时延。</strong>
排队时延：很大程度上取决与流量达到该队列的速率，链路的传输速率和到达流量的性质即流量是<strong>周期性到达</strong>还是以<strong>突发形式到达</strong>。
令 a 的表示分组到达对列的平均速率（a 的单位是以分组/秒 pkt/s)。R 是传输速率（即从队列中推出比特的速率（以 bps 即 b/s 为单位），假定所有分组的大小都是 L 比特
则比特达到队列的平均速率是 $La \ bps$ 如果 $\frac{La}{R}&gt;1$， （$\frac{La}{R}$ 被称为<strong>流量强度（tranffic intensity）</strong> )则比特到队列的平均速速率大于从队列传输出去的速率，则该队列趋向无线大，排队时延将趋向于无穷大。
（3）传输时延（发送时延）
就是将分组推到链路中所花的时间（不包括排队的时间）
（4）传播时延
分组被推到链路后，从起点到路由器所需要的时间就是<strong>传播时延</strong>
<strong>对应的公式：</strong>
\(\huge d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}\)
如果连接两台位于同一个大学的路由器的链路而言 $\huge  d_{prop}$ 可能是微不足道的，然而卫星通讯中它却是很大的，
<strong>最大吞吐量</strong>是一台路由器能够转发分组的最大速率，受到处理时延 $d_{prop}$ 的巨大影响</li>
</ol>

<h4 id="数据交换方式电路交换">数据交换方式——电路交换</h4>

<p>电路交换网络中，<strong>预留了端系统的沿路径通信所需要的资源</strong>（缓存，链路传输速率）。在分组交换中是不预留的。
在发送方能够发送信息之前，该网络必须在发送方和接受方之间建立一条连接，这是名副其实的连接，因为此时沿着发送方和接收方之间路径上的交换机都为该连接维护连接状态
在网络创建这种电路时：<strong>它在连接期间在该网络链路上预留了恒定的传输速率，所以发送方能够以确保恒定的速率向接收方传送数据</strong></p>

<p><strong>过程：</strong> 当两台主机要通信时，网络在两台主机之间创建一条专用的端到端连接（是预留的电路）</p>
<h6 id="电路交换网络中的复用">电路交换网络中的复用</h6>

<p>链路中的电路有两种复用：<strong>频分复用</strong>（Frequency-Division Multiplexing FDM) 、<strong>时分复用</strong>（Time-Division Multiplexing FDM)</p>
<ol>
  <li><strong>频分复用</strong>：在连接期间为每条连接专用一个频段。如电话网络中频段的宽度通常是 4 kHz,<strong>该宽度称为带宽（band-width)</strong>, 无线电台也是用 FDM 来共享 88~108 MHz 的频谱</li>
  <li><strong>时分复用</strong>：时间被划分为固定期间的帧，并且每个帧有被划分为固定数量的时隙。
 时分复用的具体过程：当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙，一个时隙内可用与传输该连接的数据。</li>
</ol>

<h4 id="分组交换和电路交换的对比">分组交换和电路交换的对比</h4>

<p>分组交换的缺点：</p>
<ol>
  <li>分组交换不适合实时服务（例如电话和视频会议），因为它的端到端时延时可变的和不可预测的（主要因为排队时延的变动和不可预测所致）
分组交换的优点：</li>
  <li>提供了比电路交换更好的带宽共享</li>
  <li>比电路交换更简答、更有效，实现成本更低
分组交换的性能优于电路交互的性能。
例子一：多并发用户
例子二：突然的高数据量</li>
</ol>

<p>当今电信网络逐渐向分组交换迁移</p>
<h4 id="计算机网络的吞吐量">计算机网络的吞吐量</h4>
<p><strong>瞬时吞吐量（instantaneous throughput)</strong> 是主机 B 接受到文件的速率以 bps 计
主机 B 接受到所有 F 比特用去 T 秒则文件传送的<strong>平均吞吐量 (average throughput )</strong>
$R_{s}$ 表示服务器与路由器之间的链路速率，$R_{c}$ 表示路由器与客户之间的链路速率
$min{R_{c},R_{s}   }$ 是<strong>瓶颈链路（bottleneck link）</strong> 的速率</p>

<h3 id="网络的设计模式">网络的设计模式</h3>

<ol>
  <li>分层设计模式
    <ol>
      <li><strong>分层的思想</strong>：每一层完成一种（类）特定服务/功能
        <ol>
          <li>通过层间动作完成相应的功能</li>
          <li>每层以来底层提供的服务</li>
        </ol>
      </li>
      <li>优点：
        <ol>
          <li>结构清晰</li>
          <li>
            <p>易于更新、维护</p>
          </li>
          <li>缺点：降低效率、有些功能重复出现</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h4 id="计算机网络体系结构">计算机网络体系结构</h4>

<p>是计算机网络的各层及其协议的集合，体系结构是计算机网络的功能层次及其关系的定义</p>

<h5 id="11-osi-参考模型">1.1 OSI 参考模型</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>应用层							应用层
表示层							表示层
会话层							会话层
传输层							传输层
网络层							网络层
数据链路层					   数据链路层
物理层		----------------&gt;	物理层
</code></pre></div></div>

<h5 id="12-tcpip-参考模型------tcpip-协议栈">1.2 TCP/IP 参考模型      TCP/IP 协议栈</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>应用层					HTTP|FTP|DNS
传输层					TCP  	UDP	
网际层					IP	
网络接口层			   Ethernet ATM Frame Relay	
</code></pre></div></div>

<h5 id="13-五层参考模型">1.3 五层参考模型</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>应用层						应用层
传输层  					传输层
网络层						网络层
数据链路层				   数据链路层
物理层 	-------------&gt;	物理层
</code></pre></div></div>
<h2 id="第二章应用层">第二章应用层</h2>
<p>网络应用程序体系结构：客户-服务器体系结构（client-server architrcture), 对等体系结构（P 2 P)</p>

<h3 id="进程通信的过程">进程通信的过程</h3>
<ol>
  <li>相同端上的的进程通信通过操作系统确定</li>
  <li>不同端上的进程通信通过计算机网络交换<strong>报文</strong>（message）相互通信，<strong>发送进程生成并向网络中发送报文，接收进程接受这些报文并可能通过回送报文进行响应。</strong></li>
  <li>进程通过套接字（socket）的软件接口向网络发送报文和从网络接收报文
 套接字是同一台主机内应用层和传输层的<strong>应用程序编程接口</strong>，
 应用程序可以控制套接字在应用层的一切但是，对于运输层的控制仅限于 1. 选择运输协议 2. 设定几个运输层的参数</li>
  <li>进程需要定义两种信息
    <ol>
      <li>主机的地址（主机有 IP 地址标志）</li>
      <li>在目的主机中指定接收进程的标识符（端口号）</li>
    </ol>
  </li>
  <li>选择运输服务
    <h3 id="可供应用程序使用的运输服务">可供应用程序使用的运输服务</h3>
    <h4 id="运输服务的评价">运输服务的评价</h4>
  </li>
  <li>可靠的数据传输</li>
  <li>吞吐量</li>
  <li>定时</li>
  <li>安全性
    <h4 id="tcp-服务">TCP 服务</h4>
    <p>TCP 服务模型包括：<strong>面向连接服务</strong>和<strong>可靠数据传输服务</strong></p>
  </li>
  <li>面向连接服务
 在数据报文开始流动前，TCP 让客户和服务器相互交换运输层的控制信息
 在握手阶段后，一个 TCP 连接就在两个进程的套接字之间建立了</li>
  <li>可靠的数据传输服务
 通信进程可以依靠 TCP，无差错的按适当顺序交付所有发送数据</li>
  <li>拥塞控制机制当接收端和发送端的网络拥塞时，会抑制发送进程。
    <h4 id="udp-服务">UDP 服务</h4>
    <p>UDP 不提供不必要服务的轻量级运输协议。
UDP 是无连接的，没有握手过程
UDP 协议不保证该报文将到达接收的进程，而且到达还可能是乱序的</p>
    <h3 id="应用层协议简介">应用层协议简介</h3>
  </li>
</ol>

<p>应用层协议（application-layer protocol)定义了在不同端系统上的应用进程如何传递报文。</p>
<ol>
  <li>交换报文类型，例如请求报文和响应报文</li>
  <li>各种报文的语法如报文中各个字段及这些字段是如何描述的</li>
  <li>字段的语义</li>
  <li>如何发送报文，发送报文的规则
RFC（Request for Comments）是互联网工程任务组（IETF）发布的一系列文档，用于描述互联网相关协议、标准、方法和过程。
Web 应用层协议 HTTP（超文本传输协议）就作为一个 RFC 可供使用
    <h6 id="网络应用">网络应用</h6>
  </li>
  <li>WEB</li>
  <li>文件传输</li>
  <li>电子邮件</li>
  <li>目录服务</li>
  <li>流式视频</li>
  <li>P 2 P
    <h3 id="web-和-http">Web 和 HTTP</h3>
    <h4 id="http-概述">HTTP 概述</h4>
    <p>Web 的应用是层协议是超文本传输协议（HTTP), 他是 Web 的核心
HTTP 由两个程序实现：一个客户程序和一个服务程序，HTTP 定义了这些报文的<strong>结构</strong>以及客户和服务器进行报文<strong>交换的方式</strong></p>
    <h5 id="一些概念-1">一些概念</h5>
    <p><strong>Web 页面</strong>是由<strong>对象</strong>组成，一个<strong>对象</strong>只是一个文件
多数 Web 界面含有一个<strong>HTML 基本文件（Base html)</strong>
HTTP 使用 TCP 作为它支撑运输协议
客户端的套接字接口时客户进程与 TCP 连接之间的门，在服务器的套接字接口则是服务器进程与 TCP 连接之间的门。
HTTP 不保存任何关于客户的任何信息，所以我们说 HTTP 是一个<strong>无状态协议</strong> (stateless protocol )</p>
  </li>
</ol>

<p>非持续连接和持续连接
非持续连接：即每个请求/响应对经过一个单独的 TCP 连接发送，
持续连接：是所有请求及其响应都经相同的 TCP 连接发送</p>
<h5 id="非持续连接的-http">非持续连接的 HTTP</h5>
<p>往返时间（Round-Trip Time, RTT）: 一个短分组从客户到服务器然后再返回客户所花费的时间。
RTT 包括分组传播时延，分组在中间路由器和交换机的排队时延以及分组的处理时延
三次握手：客户向服务器发送一个小 TCP 报文段，服务器用一个小 TCP 报文段做出确认和响应，最后客户向服务器返回确认。
完成三次握手的前两个部分后，客户结合三次握手的第三部分（确认）向该 TCP 连接发送一个 HTTP 请求报文。</p>

<h5 id="持续连接的-http">持续连接的 HTTP</h5>
<p>非持续连接的缺点：1. 必须为每一个请求的对象建立和维护一个全新的连接，2. 每一个对象经受两倍的 RTT 交付时延
服务器在响应后保持该 TCP 连接打开，在相同的客户和服务器之间后续的请求和响应报文能够通过相同的连接进行传送。</p>

<h4 id="http-报文格式">HTTP 报文格式</h4>
<h5 id="1-http-请求报文">1. HTTP 请求报文</h5>
<p>请求行 (request line) 分为三部分请求方法 url 协议版本
首部行 (header line)
实体体（entity body）</p>
<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/somedire/page.html</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">www.someschool.edu</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">close</span>
<span class="na">User-agent</span><span class="p">:</span> <span class="s">Mozilla/5.0</span>
<span class="na">Accept-language</span><span class="p">:</span> <span class="s">fr</span>
</code></pre></div></div>

<h5 id="2-http-响应报文">2. HTTP 响应报文</h5>

<h4 id="cookie">Cookie</h4>
<p>有 4 个组件：</p>
<ol>
  <li>在 HTTP 响应报文中的首部行中的一个 cookie 首部行</li>
  <li>在 HTTP 请求报文中的首部行中的一个 cookie 首部行</li>
  <li>在用户端系统保留一个 cookie 多文件，由用户的浏览器进行管理</li>
  <li>为与 Web 站点的一个后端数据库
    <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">响应报文中：Set-cookie: 1678
请求报文：Cookie: 1678 
</span></code></pre></div>    </div>
    <h4 id="session">Session</h4>
    <p>Session 是存在服务器中的。
服务器为每个用户浏览器创建会话对象，一个浏览器独占一个，在保存用户数据时可以保存在 Session 中，
Session 的 id 是以 cookie 的形式发送给客户端
 <strong>cookie 是存储在 client 的，而 session 保存在 server</strong>，sessionId 需要借助 cookie 的传递才有意义。</p>
    <h4 id="jwt-json-web-token">JWT (JSON Web Token)</h4>
    <blockquote>
      <p>JWT (全称：Json Web Token)是一个开放标准 (RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是<a href="https://www.zhihu.com/search?q=%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2257869896%7D">数字签名</a>的。</p>
    </blockquote>
  </li>
</ol>

<p><strong>介绍</strong>：
JWT 是由三段信息构成的，分别是 Header，Payload，Signature，将这三段信息文本用点链接一起就构成了 JWT 字符串。看起来是这个样子：aaa.bbb.ccc。</p>

<p>Header典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。例如{‘alg’:”HS256”,’typ’:”JWT”}，用Base64对这个JSON加密（是对称加密）就得到JWT的第一部分。</p>

<p>Payload载荷就是存放有效信息的地方（可以理解为皮卡的后备箱）。有效信息包含三个部分：标准中注册的声明（这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等），公共的声明（可以随意定义任何信息），私有的声明（是提供者和消费者所共同定义的声明，用于在同意使用它们的各方之间共享信息）。这三部分信息都不建议放敏感信息，因为是base64对称加密的，除非信息本身已经有做过一层加密处理。第二段信息格式例子如下：{“sub”:’123456789’,”name”:’xiaoma’,”level”:’1’}，同样进行Base64编码就得到JWT的第二部分。</p>

<p>Signature签名（可以理解为驾照），对编码过的Header、编码过的Payload、一个密钥（私钥），签名算法用是Header中指定的那个，然对它们签名得到的就是JWT的三部分。类似Signature=HS256(base64(Header)+base64(Payload)，secret)。私钥可以防止篡改和验证有效性。
<strong>那这个 token 放哪里呢？ Query 参数吗？最好把 JWT 放在 HTTP 请求的 Header Authorization，格式是 Authorization: Bearer jwtStr。</strong></p>
<h5 id="jwt-的优缺点"><strong>JWT 的优缺点</strong></h5>

<p><mark style="background: #FF5582A6;">优点</mark>
通过JWT的实现可以看出，上述的cookie和session的问题都不存在了，安全性提高，不易被攻击者利用。利用Authorization首部传输token，无跨域问题。额外信息存储在客户端，服务端占用资源不多，也不存在session共享问题。
支持跨域
无状态（指不需要在服务端保存信息）
性能（Cookie认证要比Token认证慢很多，因为Cookie使用寻找session，则token解密即可）
<mark style="background: #FF5582A6;">缺点</mark>
一次性问题(续签和废弃问题)
安全
由于jwt的payload是使用base64编码的，并没有加密，（解决，可以将payload进行加密）因此jwt中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全。
性能
jwt太长由于是无状态使用JWT，所有的数据都被放到JWT里，如果还要进行一些数据交换，那载荷会更大，经过编码之后导致jwt非常长，cookie的限制大小一般是4k，cookie很可能放不下，所以jwt一般放在local storage里面。并且用户在系统中的每一次http请求都会把jwt携带在Header里面，http请求的Header可能比Body还要大。而sessionId只是很短的一个字符串，因此使用jwt的http请求比使用session的开销大得多。
<mark style="background: #ADCCFFA6;">其他</mark>
cookie和session storage和local storage都可以在开发者工具那里看到。session storage可以设置有效时间，关闭浏览器就失效。
token 是存在 local storage 中，local storage 关闭浏览器不会失效</p>

<h4 id="web-缓存">Web 缓存</h4>
<p>Web cache 也叫<mark style="background: #ADCCFFA6;">代理服务器（proxy server</mark>）
Web 缓存器有自己的磁盘存储空间，保存最近请求过对象的副本，他是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体</p>
<ol>
  <li>浏览器创建一个到 Web 缓存器的一个 TCP 连接，并向 Web 缓存器中的对象发送一个 HTTP 请求</li>
  <li>Web 缓存器进行检查，看看本地是否存储人该对象的副本，如果有，Web 缓存器就向客户浏览器用 HTTP 响应报文返回该对象</li>
  <li>如果 Web 缓存器中没有该对象，它就打开一个与该对象的初始服务器端 TCP 连接，然后初始的服务器先缓存器发送具有该对象的 HTTP 响应</li>
  <li>当 Web 缓存器收到该对象时，它在本地存储空间存储一份副本，并向客户端浏览器用 HTTP 响应报文发送该副本（通过想现有的客户浏览器和 Web 缓存器之间的 TCP 连接）
<mark style="background: #FF5582A6;">部署 Web 缓存器的原因：</mark></li>
  <li>Web 缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与 Web 缓存器之间的瓶颈带宽更是如此</li>
  <li>Web 缓存器能大大减少一个机构的接入链路到因特网的通信量。
    <h4 id="条件-get-方法">条件 GET 方法</h4>
    <p>尽管高速缓冲器可以大大减少响应时间，但是引入了新的问题对象的副本可能是陈旧的。
HTTP 协议有一种机制：允许缓存器证实它的对象是最新的。
这种机制就是条件 GET（conditional GET）方法</p>
  </li>
  <li>请求报文使用 GET 方法</li>
  <li>请求报文中含有一个”If-Modified-Since: “首部行
    <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/fruit/kiwi.gif</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">www.exotiquecusiine.com</span>
<span class="na">If-Modified-Since</span><span class="p">:</span> <span class="s">Wed,9 Seq 2015 09:23:24</span>
</code></pre></div>    </div>
    <h4 id="http-版本更新">HTTP 版本更新</h4>
    <p><img src="/assets/attachements/Pasted%20image%2020231009111930.png" alt="" /></p>
    <h5 id="http10">HTTP/1.0</h5>
    <p>HTTP 1.0 默认使用 Connection: cloose，浏览器每次请求都需要与服务器建立一个 TCP 连接，服务器处理完成后立即断开 TCP 连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p>
    <h5 id="http11">HTTP/1.1</h5>
    <p><strong>Http 1.1</strong>
HTTP 1.1 默认使用 Connection: keep-alive（长连接），避免了连接建立和释放的开销；通过 Content-Length 字段来判断当前请求的数据是否已经全部接受。不允许同时存在两个并行的响应。</p>
  </li>
</ol>

<p><strong>为什么需要持久连接？</strong>
Http 协议的初始版本中，每进行一次 Http 通信就要断开一次 TCP 连接。每次请求都会造成 TCP 连接的建立和断开，增加通信量的开销。</p>

<p><strong>持久连接的特点：</strong></p>

<ul>
  <li>
    <p>持久连接也称为 Http keep-alive，只要任意一端没有明确提出断开连接，则保存 TCP 连接状态。</p>
  </li>
  <li>
    <p>减少了 TCP 连接的重复建立和断开所造成的额外开销，减去了服务器端的压力。</p>
  </li>
  <li>
    <p>持久连接使得多数请求以管线化方式（pipelining）成为可能。可以同时并行发送多个请求，而不需要一个接一个的等待响应了。（请求打包一次传输过去，响应打包一次传递回来），管线化的前提是在持久连接下。</p>
  </li>
</ul>

<p><strong>Http 1.1 缺陷</strong></p>

<p>（1）高延迟，带来页面加载速度的降低。（网络延迟问题只要由于队头阻塞，导致宽带无法被充分利用）</p>

<p>（2）无状态特性，带来巨大的 Http 头部。</p>

<p>（3）明文传输，不安全。</p>

<p>（4）不支持服务器推送消息。</p>

<h5 id="http2">HTTP/2</h5>
<p>SPDY 协议：2009 年谷歌公开了 SPDY 协议，主要解决 Http 1.1 效率不高的问题。</p>

<p>SPDY 被当做 HTTP 2.0 的基础，其主要特性（兼容老版本 HTTP 协议，同时可以使用 SSL 功能）都在 HTTP 2.0中得到继承。</p>

<p>HTTP 2.0：基于 SPDY，专注于性能，目标是在用户和网站直接只用一个连接。</p>

<p><strong>HTTP 2.0 新特性</strong>
（1）二进制传输</p>

<p>Http 2.0 将请求和响应数据分割为更小的帧，并且它们采用二进制编码 (http 1.0 基于文本格式)。多个帧之间可以乱序发送，根据帧首部的流表示可以重新组装。</p>

<p>（2）Header 压缩</p>

<p>Http 2.0 开发了专门的“HPACK”算法，大大压缩了 Header 信息。</p>

<p>（3）多路复用</p>

<p>Http 2.0 中引入了多路复用技术，很好的解决了浏览器限制同一个域名下的请求数量的问题。</p>

<p>多路复用技术可以只通过一个 TCP 链接就可以传输所有的请求数据。</p>

<p>（4）服务端推送</p>

<p>HTTP 2.0 在一定程度上改不了传统的“请求-应答”工作模式，服务器不再完全被动地响应请求，也可以新建“流”主动向客户端发送消息。（例如，浏览器在刚请求 html 的时候就提前把可能会用到的 JS，CSS 文件发送给客户端，减少等待延迟，这被称为“服务端推送 Server Push”）</p>

<p>服务器也不能随便将第三方资源推送给服务器，必须经过双方确认。</p>

<p><strong>HTTP 2.0 缺点</strong>
（1）TCP 以及 TCP+TLS 建立连接的延迟（握手延迟）</p>

<p>（2）TCP 的<strong>队头阻塞</strong>没有彻底解决（http 2.0 中，多个请求是跑在一个 TCP 管道中的，一旦丢包，TCP 就要等待重传（丢失的包等待重新传输确认），从而阻塞该 TCP 连接中的所有请求）</p>

<p>因为 HTTP 2.0 存在这些缺点，所以出现了 HTTP 3.0。</p>

<h5 id="http3">HTTP/3</h5>

<p>Google 在推行 SPDY 的时候意识到了上述 http 2.0 一系列问题，于是又产生了基于 UDP 协议的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。从而产生了 HTTP 3.0 版本，它解决了“队头阻塞”的问题。</p>

<p><strong>特点：</strong>
（1）实现了类似 TCP 的流量控制，传输可靠性的功能。</p>

<p>（2）实现了快速握手功能（QUIC 基于 UDP，UDP 是面向无连接的，不需要握手和挥手，比 TCP 快）</p>

<p>（3）集成了 TLS 加密功能</p>

<p>（4）多路复用，彻底解决 TCP 中队头阻塞的问题（单个“流”是有序的，可能会因为丢包而阻塞，但是其他流不会受到影响）</p>

<h5 id="总结">总结</h5>
<p>HTTP 1.1 的缺点：安全性不足和性能不高；</p>

<p>HTTP 2.0 完全兼容 HTTTP 1.0，是“更安全的 HTTP，更快的 HTTPS”，头部压缩，多路复用等技术充分利用了带宽，降低了延迟。</p>

<p>HTTP 3.0 的底层支撑协议 QUIC 基于 UDP 实现，又含 TCP 的特点，实现了又快又可靠的协议。</p>

<h3 id="smtp">SMTP</h3>
<p>Simple mail transport protocol （简单邮件传输协议）
它限制邮件报文的体部分（不只是首部）只能采用简单的 7 比特 ASCII 表示
发送邮件的过程：假设 Alice 想给 Bob 发送一封简单的 ASCII 报文</p>
<ol>
  <li>Alice 调用她的邮件代理程序并提供 Bob 的邮件地址撰写报文然后知识用户代理发送该报文</li>
  <li>Alice 的用户代理把报文发给她的邮件服务器，在那里报文被放在报文队列中</li>
  <li>运行在 Alice 的邮件服务器上的 SMTP 客户端发现了报文对你这个报文，他就创建一个到运行在 bob 邮件服务器上的 SMTP 服务器的 TCP 连接</li>
  <li>经过一些初始 SMTP 握手后 SMTP 客户通过该 TCP 连接发送 Alice 的报文</li>
  <li>在 Bob 的邮件服务器上，SMTP 的服务器接受该报文然后将报文放入 Bob 的邮箱中</li>
  <li>方便时 Bob 调用用户代理阅读该报文
<mark style="background: #FFF3A3A6;">SMTP 特点：</mark></li>
  <li>SMTP 一般不使用中间服务器发送邮件
    <h4 id="与-http-的对比">与 HTTP 的对比</h4>
    <p>两个协议都用于从一台主机向另一台主机传送文件
区别：</p>
  </li>
  <li>HTTP 主要是一个<mark style="background: #ADCCFFA6;">拉协议 (puil protocol)</mark>，SMTP 基本上是一个<mark style="background: #ADCCFFA6;">推协议（push protocol ）</mark></li>
  <li>SMTP 要求每个报文用 7 比特 ASCII 码格式，HTTP 没有这种限制</li>
  <li>如何处理一个即包含文本又包含图形的文档
    <ol>
      <li>HTTP 把每个对象封装到它自己的 HTTP 响应报文中</li>
      <li>SMTP 则把所有报文对象放在一个报文之中
        <h4 id="pop-3">POP 3</h4>
        <p>当<strong>用户代理（客户）打开了一个邮件服务器端口</strong> 110 上的 TCP 连接后 POP 3 就开始工作了。
工作阶段：</p>
      </li>
    </ol>
  </li>
  <li>特许（authorization）（鉴别用户身份）</li>
  <li>事务处理阶段（取回报文）</li>
  <li>更新阶段（删除有删除标记的报文）
    <h4 id="imap">IMAP</h4>
    <p>邮件访问协议
与 POP 3 不同的是为用户提供了创建文件夹，以及将邮件从一个文件夹移动到另一个文件夹的命令
IMAP 服务维护了 IMAP 会话的用户状态信息，例如文件夹的名字以及哪些报文和哪些报文是关联的。
IMAP 允许用户代理获取报文某些部分的命令。</p>
  </li>
</ol>

<h3 id="dns">DNS</h3>
<p>因特网的目录服务
Domain Name System (域名系统)<mark style="background: #ADCCFFA6;">基于 udp 协议，使用 52 号端口</mark>
主要任务就是：<mark style="background: #ADCCFFA6;">能进行主机名到 IP 地址的转换的目录服务</mark>
DNS 是：</p>
<ol>
  <li><mark style="background: #FF5582A6;">一个由分层的 DNS 服务器实现的分布式数据库</mark></li>
  <li><mark style="background: #FF5582A6;">一个使主机能够查询分布式数据库的应用层协议</mark>
提供服务：</li>
  <li>主机名到 IP 地址转换</li>
  <li>主机别名</li>
  <li>邮件服务器别名</li>
  <li>负载分配
    <h3 id="p-2-p">P 2 P</h3>
    <p>P 2 P 文件分发协议：BitTorrent 
自拓展性的成因：对等方除了是比特的消费者，还是他们的重新分发者</p>
    <h4 id="bittorrent">BitTorrent</h4>
    <p>BitTorrent 是一种文件分发的流行 P 2P 协议
参与一个特定文件分发的所有对等方的集合被称为一个<mark style="background: #FF5582A6;">洪流（torrent）</mark>
在一个洪流中的对等方彼此下载等长度的文件块（chunk），典型的块长度是 256 KB。
当一个对等方首次加入一个洪流中，它没有块，随着时间流逝，它积累了越来越多的块，当他下载块时同时也为其他对等方上载了多个块，一旦对等方获得了整个文件，他也许离开洪流，或者留在洪流中国年继续向其他对等方上载块。同时任何对等方可能在任何时候仅具有块的子集就离开该洪流，并在以后重新加入该洪流中。
当一个新的对等方 Alice 加入洪流时
步骤：</p>
  </li>
  <li>追踪器会发送给 Alice  50 个对等方的 IP 地址，与这个表上的所有对等方创建并行的 TCP 连接，所有成功创建 TCP 连接的对等方称为：“<mark style="background: #ADCCFFA6;">邻近对等方</mark>”</li>
  <li>在任何给定时刻，Alice 将具有块的子集，并知道它的邻居具有哪些块，这是她需要做出两个决定：1. 她应当从她的邻居请求哪些块呢？2. 应当向哪些向她请求块的邻居发送块。解决第一个问题是：最稀缺优先（rarest first），解决第二个问题是疏通
    <h3 id="视频流和内容分发网cdn">视频流和内容分发网（CDN）</h3>
  </li>
</ol>

<h2 id="第三章运输层">第三章运输层</h2>

<ul>
  <li>运输层协议是在端系统中实现的而不是路由器中，</li>
  <li>运输层将应用层的报文转换为运输层分组也就是报文段（segment），然后通过网络层封装为数据报向目的地发送</li>
  <li>封装为报文端的一个方法是：将报文划分为较小的块，并为每块加上一个运输层首部生成报文段。
    <h3 id="运输层和网络层的关系">运输层和网络层的关系</h3>
    <p>网络层提供了<mark style="background: #ADCCFFA6;">主机之间的逻辑通信</mark>
运输层协议只工作在端系统中，<mark style="background: #ADCCFFA6;">提供应用进程之间的通信机制</mark></p>
  </li>
</ul>

<h3 id="运输层协议概述">运输层协议概述</h3>
<p>UDP (用户数据报协议)提供了不可靠的，无连接的服务
TCP（传输控制协议）提供了可靠的，面向连接的服务</p>

<p>网络层协议：IP，即网际协议，IP 的服务模型是<mark style="background: #ADCCFFA6;">尽力而为交付服务（best-effort delivery service）。</mark>并不保证数据报文段按序交付。</p>
<h3 id="多路复用和多路分解">多路复用和多路分解</h3>
<p>(transport-layer multiplexing 多路复用，demultiplexing 多路分解)</p>

<p>多路<em>复用</em>（发送主机）： 从不同套接字收集数据块，并<em>为每个数据块封装上首部信息，生成报文段，</em>传递到网络层。</p>

<p>多路<em>分解</em>（接收主机）：<em>将报文段中的数据交付到正确的套接字。</em>即接收方运输层从报文段的多个字段中，识别出套接字，并将报文段定向到该套接字。</p>

<blockquote>
  <p>将网络层所提供的<em>主机到主机</em>交付服务扩展到在主机上运行的<em>应用程序到应用程序</em>的交付服务。</p>
</blockquote>

<ul>
  <li>主机上可以有<em>多个应用进程</em>运行。</li>
  <li>当运输层从底层网络接收数据时，应能<em>正确地定向</em>到相应的一个进程（<em>套接字</em>）</li>
</ul>

<h3 id="udp-协议">UDP 协议</h3>

<p>UDP是传输层的重要协议之一，另一重要协议为TCP协议。两者对比：TCP协议复杂，但传输可靠。UDP协议简单，但传输不可靠。</p>

<p>UDP协议全称为：User Datagram Protocol（用户数据报协议）。</p>

<p>它是一个简单的面向数据报的传输层协议。提供的是无连接的、不可靠的数据流传输。它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。因此报文可能会丢失、重复以及乱序等。但由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p>

<p>UDP是传输层协议，这意味着UDP的数据包需要经过IP协议的封装，然后通过IP协议传输到目的电脑。随后UDP包在目的电脑拆封，并将信息送到相应端口的缓存中。</p>

<h4 id="udp特点">UDP特点</h4>

<p>无连接指的是：UDP传输知道对应的IP和端口号就可以直接进行传输，不需要建立连接。</p>

<p><strong>理解“无连接”特性：</strong>
因为使用UDP协议的发送方和接受方之间不需要存在长期的联系。它们没有建立连接这个过程，整个消息传输过程简单来说就是“发送即结束”。在UDP协议传输的过程中，可以向某一个服务器端口发起接收数据申请，然后在下一次再向另外一个端口发起申请。</p>

<p>这样一来，一个UDP服务器接口可以在一段时间内接受多个客户端发送的请求，同样的一个UDP服务器可以从若干个不同的客户接收数据报。</p>

<p><strong>不可靠</strong>
不可靠指的是UDP协议没有任何安全机制，发送端发送数据报后，如果出现丢包等现象，UDP协议层也不会给应用层返回任何错误信息。</p>

<p>只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。因此报文可能会丢失、重复以及乱序等。</p>

<p><strong>面向数据报</strong>
应用层交给UDP多长的报文，UDP会将其原样发送，既不会拆分，也不会将其合并。</p>

<p>如果，发送端一次性发送1000个字节，那么接收端也必须一次性接收1000个字节，不能将其拆为100份，每份10字节，每次接收一份。</p>

<p><strong>缓冲区</strong>
UDP只有接收缓冲区，没有发送缓冲区。</p>

<p>UDP没有真正意义上的发送缓冲区。发送的数据会直接交给内核，由内核将数据传给网络层协议进行后续的传输动作。</p>

<p>UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到的UDP数据报的顺序和发送UDP报的顺序一致；如果缓冲区满了，再达到的UDP数据就会被丢弃。</p>

<p><strong>大小受限</strong>
UDP协议首部中有一个16位的最大长度，也就是说一个UDP能传输的数据的最大长度是64K(包含了UDP的首部)。</p>

<p>这是UDP在使用中的一个致命缺陷，也就是说UDP无法直接表示一个比较大的数据报。</p>

<p>解决方法：
可以在应用层，针对大的数据报进行分包（拆分成多个部分），然后再通过多个UDP数据报分别发送（但是这样子无法保证顺序）接收方再将收到的几个包拼接成完整的数据。</p>

<p>上述这种方式是下策。</p>

<p>上策是：将其改成TCP协议，TCP协议没有这样的长度限制。</p>

<h4 id="报文格式">报文格式</h4>

<p><img src="/assets/计算机网络.assets/a54a639a4f7a9cefc1c70a08c5350801.png" alt="img" /></p>

<p>实际格式</p>

<p><img src="/assets/计算机网络.assets/980f4c985dc6c6061340baf6233a478b.png" alt="img" /></p>

<p><strong>源端口号和目的端口号</strong>
用来标记发送和接受的应用进程。因为UDP不需要应答，所以源端口是可选的，如果源端口不用，那么置为零。</p>

<p>当运输层从IP层收到UDP数据报时，就是根据首部中的目的端口，把UDP数据报通过相应的端口，上交最后的终点–应用程序。</p>

<p><strong>UDP长度</strong>
16位UDP长度，表示整个数据报（UDP首部+UDP数据）的最大长度</p>

<p><strong>UDP校验和</strong>
校验和用来验证网络传输的这个数据是否是正确的，本质上是光信号和电信号（会被外界因素干扰，导致信号出错）。</p>

<p>校验和正确，不能保证数据100%是对的，但校验和不正确，数据100%是不对的。</p>

<h3 id="可靠传输协议rdt-10-rdt-20-rdt-30-tcp">可靠传输协议（rdt 1.0 rdt 2.0 rdt 3.0 tcp）</h3>

<p>计算机网络的设计基本方案是复杂化，多功能化应用层，运输层的协议设计，从而使得网络层，链路层，物理层变得相对简单，网络搭建的物质条件变得简单。由于网络层较为简单，采用了无连接的协议，在不可靠信道上传输，导致数据传输是不可靠的。为了保证数据传输的可靠性，我们选择在运输层采用复杂的rdt（可靠数据传输协议），以完成网络的可靠性。</p>

<p><img src="/assets/计算机网络.assets/20180520092825298.png" alt="img" /></p>

<h4 id="rdt-10-fsm-优先状态机">rdt 1.0 （FSM 优先状态机）</h4>

<p>rdt1.0是基于理想情况下的协议，假设所有信道都是可靠的，没有比特位的翻转，没有数据包的丢失与超时，所以rdt1.0的传输功能就是 发送方发送数据，接收方接受数据。</p>

<p><img src="/assets/计算机网络.assets/20180520094953115.png" alt="img" /></p>

<h4 id="rdt-20">rdt 2.0</h4>

<p>rdt2.0在rdt1.0的基础上解决了比特位翻转的问题，这里的比特位防撞发生在运输层下面的不可信信道中数据包中的1可能会变0，0可能会变成1。</p>

<p>rdt2.0增加了3种新机制：</p>

<ol>
  <li>
    <p>错误检验</p>
  </li>
  <li>
    <p>接收者反馈接受信息（ACK,NAK）</p>
  </li>
  <li>
    <p>重传机制。</p>
  </li>
</ol>

<p>在运输层对应用层的数据进行打包处理时，新增<strong>checksum（校验和）</strong>，从而接收端可以对其数据包进行检验，<strong>如果正确，返回ACK</strong>，发送者继续发送下一个数据包；<strong>如果不正确，返回NAK</strong>，发送者<strong>重传</strong>数据。
但是rdt2.0有着一个致命的缺点，<strong>只考虑了发送方到接收方的数据传输，如果反馈信息ACK，NAK传输时发生比特位翻转会出现什么情况？</strong>如果ACK发生翻转，那么发送方会再次重复的发送相同的数据包；如果NAK发生翻转，那么发送方会认为数据传输情况很好，但是接收方却已经收到了一个错误的数据包。</p>

<p>由此<strong><em>rdt2.1</em></strong>应运而生，在rdt2.0的基础之上，<strong>发送方在打包数据包时添加了0或者1编号，同样ACK,NAK字段上也添加了0，1字段，表示0.1号字段的确认或者否定。</strong>发送方就有了2种状态发送0号数据包，1号数据包，接收方也有了2种状态等待0号数据包和等待1号数据包。现在假设情景发送方向接收方发送0号数据包，如果接收方接收到0号数据包，返回ACK，但是ACK出现翻转，接收方处于等待1号数据状态，发送方重复发送0号数据，接收方会拒绝0号数据，避免重复。如果接收方接收到0号数据包出现错误，返回NAK，但是NAK出现翻转，接收方处于等待0号数据状态，发送方继续发送1号数据，接收方会拒绝1号数据，避免错序。</p>

<p><strong><em>rdt2.2</em></strong>是在rdt2.1上的基础之上做了小小的改善，摒弃了NAK，只需采用ACK。我<strong>们在ACK的信息上加上了期望的顺序号，</strong>现在假设情景发送方向接收方发送0号数据包，如果接收方接收到0号数据包，返回（ACK，1），发送方接着发送1号数据包。如果接收方接收到0号数据包出现错误，返回（ACK，0），发送方重传0号数据包。</p>

<h4 id="rdt-30">rdt 3.0</h4>

<p>rdt2.2之前的版本都重在处理数据包的比特位翻转情况，却没有考虑到数据包在传输过程中出现的数据包丢失问题，这样数据包丢失会使得网络处于拥塞状态。</p>

<p><strong>rdt3.0在rdt2.2的基础之上处理了数据包丢失的情况，增加了计时器的机制，</strong>如果在RTT时间段内，发送方没有接收到反馈信息，那么发送方默认数据包已经丢失了，会自动重传。</p>

<p><strong>rdt3.0 可以工作, 但是性能很差</strong></p>

<h4 id="流水线可靠数据传输协议">流水线可靠数据传输协议</h4>
<ol>
  <li>
    <p>回退 N 步</p>

    <p>go-Back-N（回退N重传协议）：</p>

    <ol>
      <li>
        <p>发送者在流水线中最多有 N 个未确认的数据报。</p>
      </li>
      <li>
        <p>接收者仅发送累计的确认 ，如果中间有数据报缺失，就不予以确认。</p>
      </li>
      <li>
        <p>发送者对最久未确认的数据报进行计时，如果计时器到点, 重传所有未确认的数据报。</p>
      </li>
      <li>
        <p>发送窗口大于1，接受窗口等于1（也就意味着如果某一个报文段出现错误，那么接受窗口会停留再次，之后收到的数据将会被丢弃）</p>

        <p><img src="/assets/计算机网络.assets/20180520112106897.png" alt="img" /></p>
      </li>
    </ol>
  </li>
  <li>
    <p>选择重传</p>

    <ol>
      <li>发送者在流水线中最多有 N 个未确认的数据报。</li>
      <li>
        <p>接收者对单个数据报进行确认。</p>
      </li>
      <li>
        <p>发送者对每一个未确认的数据报进行计时，如果计时器到点, 仅重传该个未确认的数据报。</p>
      </li>
      <li>
        <p>发送窗口大于1，接受窗口大于1（意味着可以缓存出错位置之后的报文段），最好是两者相同。</p>

        <p><img src="/assets/计算机网络.assets/20180520112121897.png" alt="img" /></p>
        <h3 id="面向连接的运输-tcp-协议">面向连接的运输： TCP 协议</h3>
        <h4 id="tcp-连接">TCP 连接</h4>
      </li>
    </ol>
  </li>
</ol>

<p>为什么要建立连接</p>

<ol>
  <li>更好的保证可靠性: 建立连接的过程其实就是让通信双方验证各自的发送能力和接受能力是否正常</li>
  <li>协商一些重要参数 (如: 序号的初始值)</li>
</ol>

<h5 id="三次握手">三次握手</h5>

<p><strong>三次握手:</strong> 双方各自向对方发起建立连接的请求，再各自给对方回应，只不过，中间的 SYN 和 ACK 能合并在一起</p>

<p>举例：A 给 B 打电话，打电话同样要验证自己以及对方的话筒和听筒是否正常工作</p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5py16Iqx6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center.png" alt="在这里插入图片描述" /></p>

<p>第一次握手： 刚开始，A 不知道自己和 B 手机的听筒和话筒是否正常，所以 A说”喂，你能听到吗?”
第二次握手： B 听到后，说明 A 的话筒和 B 的听筒正常，但 B 还需进一步检查自己的话筒和 A 的听筒是否正常；同时 B 把 A 话筒正常和自己听筒正常的消息传递给 A；于是 B “我能听到，你呢？”
第三次握手： A 收到 B 的消息后，就证明了 A 听筒正常，B 话筒正常</p>

<p>以上三次握手就保证了 A、B 的听筒和话筒都正常，也就保证了通话的正常，这就类似于网络建立连接时的三次握手</p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5py16Iqx6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center-1705371196149-18.png" alt="在这里插入图片描述" /></p>

<p>第一次握手： 客户端向服务器发送 SYN 报文 (SEQ=x，SYN=1)，并进入 SYN_SENT 状态，等待服务器确认</p>

<p>第二次握手： 实际上是分两部分来完成的，即 SYN+ACK (请求和确认) 报文
服务器收到了客户端的请求，向客户端回复一个确认信息 (ack=x+1)
服务器再向客户端发送一个 SYN 包 (SEQ=y)建立连接的请求，此时服务器进入 SYN_RECV 状态</p>

<p>第三次握手： 客户端收到服务器的回复 (SYN+ACK 报文0)；此时，客户端也要向服务器发送确认包 (ACK)；此包发送完毕客户端和服务器进入 ESTABLISHED 状态，完成 3 次握手</p>

<p>建立连接的过程，相当于通信双方各自给对方发送 SYN，在各自给对方发送给 ACK，只不过中间的 ACK 和 SYN 合二为一了，于是最后就是”三次握手”</p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5py16Iqx6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center-1705371231704-21.png" alt="真实的" /></p>

<blockquote>
  <p><strong>1.两次握手可以吗？？</strong>
<strong>不可以</strong></p>

  <ul>
    <li>
      <p>防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源</p>
    </li>
    <li>
      <p>两次握手只能保证单向连接是通畅的 (为了实现可靠数据传输， TCP 协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的；三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认）</p>
    </li>
  </ul>

  <p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5py16Iqx6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center-1705371357022-24.png" alt="在这里插入图片描述" /></p>

  <p><strong>2.为什么是三次？？</strong>
主要是为了建立可靠的通信通道，<strong>保证客户端与服务端同时具备发送、接收数据的能力</strong></p>

  <p><strong>3.四次握手可以吗？？</strong>
可以，但没必要
四次握手可以验证双方的发送接收能力正常，但是这样做效率比较低</p>

  <p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5py16Iqx6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center-1705371402009-27.png" alt="在这里插入图片描述" /></p>
</blockquote>

<h5 id="四次挥手">四次挥手</h5>

<p><strong>四次挥手:</strong> 双方各自向对方发起建立连接的请求，再各自给对方回应，只不过，中间的 FIN 和 ACK 不一定能合并在一起</p>

<p>仍以打电话为例，如下图：</p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5py16Iqx6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center-1705371465994-30.png" alt="在这里插入图片描述" /></p>

<p><strong>TCP 中真实的断开连接过程：</strong> (假设主机 A 主动断开连接)</p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5py16Iqx6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center-1705371492505-33.png" alt="在这里插入图片描述" /></p>

<ul>
  <li>
    <p>第一次挥手: 客户端向服务器端发送断开 TCP 连接请求的 [FIN，ACK] 报文，在报文中随机生成一个序列号 SEQ=u，表示要断开 TCP 连接</p>

    <p>此时，客户端进入FIN_WAIT_1 (终止等待1) 状态</p>
  </li>
  <li>
    <p>第二次挥手: 当服务器端收到客户端发来的断开 TCP 连接的请求后，回复发送 ACK 报文，表示已经收到断开请求。回复时，随机生成一个序列号 SEQ=v；由于回复的是客户端发来的请求，所以在客户端请求序列号 SEQ=u 的基础上加 1，得到 ack=u+1</p>

    <p>此时，服务端就进入了CLOSE_WAIT (关闭等待) 状态，客户端收到ACK后，就进入FIN_WAIT_2 (终止等待2) 状态</p>
  </li>
  <li>
    <p>第三次挥手: 服务器端在回复完客户端的 TCP 断开请求后，不会马上进行 TCP 连接的断开。服务器端会先确认断开前，所有传输到客户端的数据是否已经传输完毕。确认数据传输完毕后才进行断开，向客户端发送 [FIN，ACK] 报文，设置字段值为 1。再次随机生成一个序列号 SEQ=w；由于还是对客户端发来的 TCP 断开请求序列号 SEQ=u 进行回复，因此 ack 依然为 u+1</p>

    <p>此时，服务器就进入了LAST_ACK (最后确认) 状态</p>
  </li>
  <li>
    <p>第四次挥手: 客户端收到服务器发来的 TCP 断开连接数据包后将进行回复，表示收到断开 TCP 连接数据包。向服务器发送 ACK 报文，生成一个序列号 SEQ=u+1；由于回复的是服务器，所以 ACK 字段的值在服务器发来断开 TCP 连接请求序列号 SEQ=w 的基础上加 1，得到 ack=w+1</p>

    <p>此时，客户端就进入了TIME_WAIT (时间等待) 状态；注意此时TCP连接还没有释放，必须经过2MSL (最长报文段寿命) 的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态</p>
  </li>
</ul>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5py16Iqx6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center-1705371683386-36.png" alt="在这里插入图片描述" /></p>

<blockquote>
  <p><strong>1.四次挥手，三次挥完行不行？？</strong>
通常情况下不行，若触发了延时应答机制，就可以三次挥完
“不行”，即：上述的 ② ③ 为什么没有合并在一起？？
因为中间两次操作的时机不一样
ACK 是收到 FIN 之后立刻由内核返回的数据报，FIN 是应用程序处理完接受缓冲区的数据之后，调用的 close 方法触发的
.
<strong>2.为什么四次？？</strong>
因为要确保客户端和服务端的数据能够完成传输
.
<strong>3.为什么 TIME_WAIT 状态要等待 2MSL？？</strong>
假设网络上传输数据的最大时间为 MSL
MSL 就是 ACK / FIN 从主机 A 到主机 B 的最大时间
TIME-WAIT 等待时间，需要分成两个部分：
①等待 ACK 经历一个最大时间到达主机 B
②万一 ACK 丢了，在等待一个最大时间，主机 B 重传 FIN 到达主机 A
因此，TIME_WAIT 就需要等待 2倍的MSL，即：2MSL
原因：</p>

  <p>确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接
第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端；服务端会超时重传 FIN / ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN / ACK 报文的确认，就无法正常断开连接
MSL 是报文段在网络上存活的最长时间，客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN / ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器；如此保证服务端能够正常关闭
如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接
防止已失效的连接请求报文段出现在之后的连接中
TCP 要求在 2MSL 内不使用相同的序列号；客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失；这样就可以使下一个连接中不会出现这种旧的连接请求报文段；或者即使收到这些过时的报文，也可以不处理它</p>
</blockquote>

<h4 id="报文结构">报文结构</h4>

<p><img src="/assets/计算机网络.assets/56e0f77724ee4d2e8ccaf9847b800236.png" alt="TCP报文格式" /></p>

<ul>
  <li>
    <p><strong>源/目的端口：</strong>表示数据从哪个进程发送，发送到哪个进程去</p>
  </li>
  <li>
    <p><strong>32位序号 seq：</strong>Sequence number 缩写seq ，TCP通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据有序，也可以理解为：本次传输数据的起始字节在整个数据流中的位置。比如现在序列号为1000，发送了1000，下一个序列号就是2000。</p>
  </li>
  <li>
    <p><strong>32位确认号 ack:</strong> Acknowledge number 缩写ack，TCP对上一次seq序号做出的确认号，用来响应TCP报文段，给收到的TCP报文段的序号seq加1。也可以理解为： 期望收到下一包的序号，用于确认已经收到数据的偏移序号。</p>
  </li>
  <li>
    <p><strong>4位TCP报头长度：</strong>表示TCP头部有4个字节（32位），所以TCP头部最大长度为15*4=60</p>
  </li>
  <li>
    <p><strong>数据偏移：</strong>占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段指出TCP报文段的首部长度（报头长度）。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，注意，“数据偏移”的单位不是字节，而是4字节。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节（15*4字节），这也是TCP首部的最大字节（即选项长度不能超过40字节=60-20）。</p>

    <blockquote>
      <p>首部长度（报头长度） - 20字节 = 选项长度
如果数据偏移的值是5，此时表示整个TCP报头的长度是 4x5 = 20字节(此时相当于没有选项)
如果数据偏移的值是15，此时表示整个TCP报头的长度是4x15 = 60字节(此时相当于选项是40个字节)</p>
    </blockquote>
  </li>
  <li>
    <p><strong>6个boolean值标志位：</strong></p>

    <blockquote>
      <p>URG：简写为U，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；
ACK：简写为.，确认标志位，对已接收的数据包进行确认；仅当 ACK = 1时确认号字段才有效，当 ACK = 0时确认号无效。TCP 规定，在连接建立后所有的传送的报文段都必须把 ACK 置为1。
PSH：简写为P，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；
RST：简写为R，重置标志位，用于连接复位、拒绝错误和非法的数据包；
SYN：简写为S，同步标志位，用于建立会话连接，同步序列号；在连接建立时用来同步序号。当 SYN = 1而 ACK = 0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1和 ACK = 1，因此 SYN 置为1就表示这是一个连接请求或连接接受报文。
FIN： 简写为F，完成标志位，表示我已经没有数据要发送了，即将关闭连接；</p>
    </blockquote>
  </li>
  <li><strong>16位窗口大小：</strong>进行流量窗口控制</li>
  <li><strong>16位校验和：</strong>检验数据是否一致</li>
  <li><strong>16位紧急指针：</strong>标识哪部分数据是紧急数据</li>
</ul>

<h4 id="流量控制">流量控制</h4>

<blockquote>
  <p>接收端主机处理数据的速度有限，如果发送端发送数据太快，导致接收端缓冲区被填满，这时，发送端继续发送数据的话就会造成丢包，继而引起丢包重传等一些列连锁反应，因此TCP协议根据接收端接收数据的能力，来决定发送端发送数据的速度，这个机制就叫作流量控制</p>

</blockquote>

<ul>
  <li>接收端将自己剩余缓冲区大小存入TCP头部中的“16位窗口大小”字段 ，通过ACK通知发送端</li>
  <li>窗口大小越大，说明网络吞吐量越高</li>
  <li>发送端根据接收到这个窗口的大小，控制自己的发送速度</li>
  <li>如果接收缓冲区满了，就会将窗口设置为0，这时，发送端不在发送数据，而是定期的发送一个窗口探测报文（只是为了知道窗口的大小），让接收端将窗口大小告诉发送端</li>
</ul>

<h4 id="拥塞控制">拥塞控制</h4>

<p>刚开始发送数据时，由于中间结点的网络情况不清楚，如果贸然发送大量数据，就会造成大量丢包，所以TCP协议引入慢启动的方式，先发少量数据探探路，再决定按照多大速度发送数据</p>

<p>此处引入拥塞窗口，刚开始时，拥塞窗口设置为1，每收到一个ACK时，拥塞窗口加1，每次发送数据的时候，拥塞窗口和流量窗口的较小的值作为实际发送的窗口，即滑动窗口的大小</p>

<blockquote>
  <p><strong>拥塞控制和流量控制的区别？</strong></p>

  <p>对于【拥塞控制】而言， 其实就是要防止过多的数据注入到网络，使得网络中的路由器或链路不至于过载，而且它是一个全局性的过程，会接收到不同主机、路由器所发送过来的数据，那么这个中心的交换节点就会同时被使用，从而到导致繁忙进而造成拥塞，可是呢接收方在这么繁忙的情况下又很难去知道、去查询是哪个主机出了问题
 对于【流量控制】而言，要做的就是抑制发送端发送数据的速率，以使接收端来得及接收。它是一个点对点通信量的控制，是个端到端的问题</p>
</blockquote>

<h5 id="tcp的拥塞控制方法">TCP的拥塞控制方法</h5>

<p>了解了拥塞控制的一半原理，接下去我们来聊聊TCP面对这样的拥塞状况是如何应付的</p>

<p>为了集中讨论拥塞控制，假定：</p>

<ul>
  <li>数据是单方向传送的，对方只传送确认报文</li>
  <li>接收方总是有足够大的缓存空间，因为发送窗口的大小由网络的拥塞程度来决定</li>
</ul>

<p><strong>接收窗口【rwnd】与拥塞窗口【cwnd】：</strong>
在流量控制中，我们提到了rwnd接收窗口，是由接收方维护的。表示接收方示意发送方自己可以接受的数据大小，以此来控制发送方发送数据的大小，
在拥塞控制中我们再来聊聊一种窗口叫做cwnd拥塞窗口，它呢是由发送方维护的。它的大小取决于网络的拥塞程度，并且是动态变化着的。因为上面我们假定接收方的接收窗口足够大，因为发送方只需要考虑拥塞窗口的大小即可</p>

<p><strong>总结：</strong></p>

<p>【接受窗口 rwnd】：由接收方维护，会根据接收缓存设置的值，并告知给发送方，反映接收方容量</p>

<p>【拥塞窗口 cwnd】：由发送方维护，会根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量</p>

<p><strong>发送方控制拥塞窗口的原则：</strong></p>

<p>只要网络没有出现拥塞，拥塞窗口就可以增大一些，将更多的数据发送出去，以此来提高网络利用率
当网络出现拥塞或可能要出现拥塞时，就把拥塞窗口减小一点，减少注入到网络的分组数，以便缓解网络出现的拥塞</p>

<blockquote>
  <p>发送方如何知道网络出现了堵塞？</p>

  <p>没有按时收到对方的确认报文，超时重传计时器启动，便判断出网络出现了拥塞</p>
</blockquote>

<p><strong>慢开始和拥塞避免算法</strong></p>

<blockquote>
  <p>接下去我们来介绍一下拥塞控制中的算法，首先是慢开始和拥塞避免算法这两种，它们是配合使用的</p>
</blockquote>

<p><img src="/assets/计算机网络.assets/c731b15610f04ffbbcaf10241265ed34.jpeg" alt="在这里插入图片描述" /></p>

<p>【慢开始算法原理】：由小到大逐渐将数据字节注入到网络中，即逐渐增加拥塞窗口的数值</p>

<p>接着你要知道一个东西叫做最大报文段SMSS，因为慢开始规定，每收到一个新的报文段后，可以把拥塞窗口增加最多一个SMSS的值。然后通过下面这个例子来介绍一下慢开始算法</p>

<p>从上图可以看出，对于发送方它首先设置【cwnd = 1】，发送出第一个报文段，然后接收方确认了这个报文段再发送回一个确认报文段，这一点我们在前面TCP流量控制中也有说到过，这么一趟来回就叫做一个轮次，也可以叫做往返时延RTT
经过了一个往返时延后，发送方便扩大拥塞窗口，令【cwnd = 2】，连续发出了两个报文段，然后接收方那个接收到之后就进行了返回确认，这是第二轮的RTT
那发送方收到这两个确认报文段之后，便继续扩大自己的拥塞窗口，令【cwnd = 4】，一样，接收方接收到之后又会返回确认，这是第三轮的RTT
依此类推。。。发送方若是试探到本网络的拥塞状况良好，就会不断地增加自己的拥塞窗口，尽快地将数据发送出去。这种慢开始的策略可以使得网络拥塞的概率减小↓
从上可以知道拥塞窗口在慢开始算法下会不断地增大，<strong>但是若是太大也不好，也会造成过多的数据涌入导致网络拥塞，因此便有了[慢开始门限ssthresh]这么一个状态变量，它的用法如下</strong>👇</p>

<p>当【cwnd &lt; ssthresh】时，使用上述的慢开始算法
当【cwnd &gt; ssthresh】时，停止使用慢开始算法而改用拥塞避免算法
当【cwnd = ssthresh】时，即可使用慢开始算法，也可使用拥塞避免算法
【拥塞避免算法原理】：让拥塞窗口cwnd按线性规律缓慢增长，每个轮次RTT只加1</p>

<p>然后我们便可以通过下面这张曲线图来看出TCP的拥塞窗口cwnd是如何变化的</p>

<p><img src="/assets/计算机网络.assets/e77e164bc2004fb19beeadcc61bd1096.jpeg" alt="在这里插入图片描述" /></p>

<p><strong>快重传和快恢复算法</strong>
然后再来简单介绍一下快重传和快恢复这两个算法</p>

<p>【快重传算法原理】：让发送方尽早知道发生了个别报文段丢失的情况，若发送方一连收到三个重复确认，便会立即重传接收方需要的报文段</p>

<p>对于这三次报文的重复确认，就是我们前面介绍过的冗余ack</p>

<p>【快恢复算法原理】：当发送端收到连续三个重复的确认时，不执行慢开始算法，而是执行快恢复算法算法</p>

<p>对于慢开始算法而言，会使拥塞窗口降到1后再使用拥塞避免算法慢慢升回到调整后的慢开始门限值
对于快恢复算法而言，<strong>不会使拥塞窗口降到最小值1，</strong>而是降到门限值ssthresh / 2的位置，然后再次执行拥塞避免算法，使拥塞窗口缓慢地线性增大</p>

<p>以下是【TCP拥塞控制】的整个流程图，可以再对照回顾一下</p>

<p><img src="/assets/计算机网络.assets/4220ae1661434b69b5d0eb6e39504df1.jpeg" alt="在这里插入图片描述" /></p>

<h6 id="tahoe"><strong>Tahoe</strong></h6>

<p>Tahoe是TCP的最早版本，其主要有三个算法去控制数据流和拥塞窗口。</p>

<p>Slow Start（慢启动）
（ssthresh：slow start thresh，慢启动门限值）
当cwnd的值小于ssthresh时，TCP则处于slow start阶段，每收到一个ACK，cwnd的值就会加1。
仔细分析，其实慢启动并不慢，经过一个RTT的时间，cwnd的值就会变成原来的两倍，实为指数增长。
Congestion Avoidance（拥塞避免）
当cwnd的值超过ssthresh时，就会进入Congestion Avoidance阶段，在该阶段下，cwnd以线性方式增长，大约每经过一个RTT，cwnd的值就会加1
Fast Retransmit（快重传）
按照拥塞避免算法中cwnd的增长趋势，迟早会造成拥塞（一般通过是否丢包来判断是否发生了拥塞）。
如果中网络中发生了丢包，通过等待一个RTO时间后再进行重传，是非常耗时的，因为RTO通常设置得会比较大（避免伪重传：不必要的重传）。
快重传的思想是：只要发送方收到了三个重复的ACK（如果不了解三个重复ACK如何产生，请温故一下滑动窗口协议），就会立马重传，而不用等到RTO到达（如果没有3个重复的ACK而包丢失了，就只能超时重传）；
并且将ssthresh的值设置为当前cwnd的一半，而cwnd减为1，重回slow start阶段。</p>

<h6 id="reno"><strong>Reno</strong></h6>

<p>除了包含Tahoe的三个算法，Reno多了一个Fast Recovery（快速恢复）算法。</p>

<p>当收到三个重复的ACK或是超过了RTO时间且尚未收到某个数据包的ACK，Reno就会认为丢包了，并认定网络中发生了拥塞。
Reno会把当前的ssthresh的值设置为当前cwnd的一半，但是并不会回到slow start阶段，而是将cwnd设置为（更新后的）ssthresh+3MSS，之后cwnd呈线性增长。</p>

<h4 id="gbnsrtcp的联系与区别">GBN、SR、TCP的联系与区别</h4>

<blockquote>
  <p>​    <strong>重传</strong> 对于丢失分组 n，在GBN中，发送方会重传n及n以后的数据包；在SR中，只会重传n。</p>

  <p>​    <strong>缓存</strong> 对于乱序达到的分组，在GBN中，接受段端会直接丢弃；在SR中，会把它们缓存下来。</p>

  <p>​    定时器 在GBN中一个连接只会设置一个定时器，在SR中会为每个分组设置定时器。</p>

  <p>​    而TCP呢？</p>

  <p>​    <strong>重传和缓存像SR，定时器像GBN。</strong></p>
</blockquote>

<p>​    TCP协议中的ack指的是 期望收到的分组。而GBN，SR中ack指的是已经确认的分组。</p>

<p><strong>GBN：</strong>
如果某个报文段没有被正确接收，则从这个报文段到后面的报文段都要重新发送。
采用累计应答的方式。例如接收端返回ACK=3，则证明报文段3以及之前的报文段都被正确接收。
这里顺便解释一下为什么GBN可以采用累计应答的方式？怎么就能保证3之前的被正确接收了呢？
这还要由GBN的工作机制来决定：在GBN机制下，在接收端的运输层一次只交付给上层一个分组，并且保证是按序交付的，因此如果分组k已接收，则所有序号小于k的分组也已经交付了。
接收端不对失序到达的分组进行缓存。
<strong>SR：</strong>
接收方设置缓存区，用于接收失序到达的分组。（从这里可以感受到，所谓的GBN中的发送端窗口和SR中的发送端与接收端的窗口其实就是缓存区，用于缓存分组。注意，由于GBN是单个分组交付，不设置缓存区，所以GBN的接收端是没有窗口的）
为每个报文段设置单独的计时器，单个分组计时器超时只重发这一个报文段。
接收端返回ACK是当前接收成功报文段的序号，SR不采用累计应答的方式。
<strong>TCP：</strong>
TCP使用累计应答的方式。这一点与GBN类似。
TCP在接收端会设置缓存，来缓存正确接收但是失序的分组，这点与SR类似。（实际上TCP RFC并没有对接收端要怎样处理失序到达的分组提出要求，但是在接收端设置缓存是实践中大家都采用的方法）
TCP使用快速重传机制：如果收到对于一个特定报文段的3个冗余ACK，则在超时事件发生前就会对该报文段进行重传，这大大节约了时间。
注意：TCP中的ACK是指接收端希望从发送端收到的下一字节的序号。例如发送端发送了编号为0-5的字节，这时接收端成功接收后就会发送ACK为6。
注意：这里介绍的TCP这是理论上的，在实际使用过程中，大家加入了很多其他的机制等。目前计网学习的都是基础理论的知识。</p>

<p>​    GBN和SR是滑动窗口协议的两个典型例子，可以看做是“理论”协议，实际协议可以完全按着GBN或SR协议实现，当然也可以根据需要引入或综合不同的机制。TCP协议可以认为综合了GBN协议和SR协议的一些机制，比如TCP协议采用累积确认机制、通常在接收端提供缓存等。</p>

<h2 id="第四章网络层">第四章网络层</h2>

<blockquote>
  <p><strong>参与网路层的主要设备：</strong></p>

  <p>从输入来链路接口到输出链路接口转移分组的是<strong>交换机</strong></p>

  <p>基于链路层帧中的字段做出决定的分组交换机称为<strong>链路层交换机</strong></p>

  <p>基于网络层数据报中的首部字段的值做出转发决定的是<strong>路由器</strong></p>
</blockquote>

<h3 id="网络层的作用">网络层的作用</h3>

<p>网络层的作用：将分组从一台发送主机移动到另一台接收主机。</p>

<ul>
  <li>转发</li>
  <li>路由选择</li>
</ul>

<p>在网络体系中，每一层都是服务于对应的上下层的。网络层也是服务于上层的传输层和下层的数据链路层。</p>

<p>网络层的功能就是让我们在茫茫人海中，能够找到另一台计算机在哪里，是否属于同一个子网等。</p>

<p>其主要作用表现在一下几个方面：</p>

<p><strong>（1）屏蔽网络差异，提供透明传输</strong></p>

<p>网络层就是为了解决不同网络有不同的规范要求的差异问题，寻找一个不同网络间都能共同遵守的网络通信规范，以便不同网络间能相互识别，并接受对方的网络请求。也就是一个中转站的作用，两个毫无交集的网络通过这个中转站来建立交集。</p>

<p><strong>（2）为网络间通信提供路由选择</strong></p>

<p>路由选择是根据一定的原则和路由选择算法在多个结点的通信子网中选择一条到达目的节点的最佳路径的过程。确定路由选择的策略称为路由算法。在无连接的数据包服务中，网络节点要为每个数据包做出路由选择，即选择到达目的节点的最佳路线，而在面向连接的虚电路服务中，存在一条专门的逻辑线路，在建立连接时就已经确定了路有路径，无需额外选择。</p>

<p><strong>（3）拥塞控制</strong></p>

<p>拥塞控制是为了避免网络传输路径中数据的传输延迟或死锁。数据链路层中的流量控制功能，是针对数据链路中点对点传输速率的控制，这里的拥塞控制是针对在网络层传输路径中的端到端传输效率的控制。主要采用预约缓冲区、许可证和分组丢弃等方式。</p>

<h3 id="路由器的工作原理">路由器的工作原理</h3>

<h4 id="路由器的构成">路由器的构成</h4>

<p><img src="/assets/计算机网络.assets/abadb70c3e484a45be5d78fbdbe04db3.png" alt="img" /></p>

<p><strong>路由器的任务</strong></p>

<p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组</p>

<p>路由器将某个输入端口收到的分组，按照分组要去的目的地（即目的网络）， 把该分组从路由器的某个合适的输出端口转发给下一跳路由器</p>

<p>下一跳路由器也按照这种方法处理分组，直到该分组到达终点为止</p>

<p><strong>转发和路由选择的区别</strong>
转发：就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去</p>

<p>路由选择：则是按照路由选择算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由</p>

<p>路由表是根据路由选择算法得出的。而转发表是由路由表生成的</p>

<p>典型的路由器结构</p>

<p><img src="/assets/计算机网络.assets/abadb70c3e484a45be5d78fbdbe04db3-1705388031985-54.png" alt="img" /></p>

<p>​     若分组的接收者是路由器自己，需要交给相应的  上层协议  去处理，如发送给路由器的RIP或 OSPF分组等需要    送交路由器的路由选择部分中的路由选择处理机。</p>

<p>​    否则，网络层处理模块按照   分组首部中的   目的地址   查找转发表，交给交换结构交换到合适的输出端口。</p>

<p><img src="/assets/计算机网络.assets/2780b75559fb4747967ff5482dc6d84f.png" alt="img" /></p>

<p>若交换结构处理分组的速率赶不上分组进入队列的速率，则会导致输入队列排队！</p>

<h4 id="交换结构">交换结构</h4>

<p><strong>1. 经内存存储器交换</strong></p>

<p>最早的路由器就是多网络接口的计算机，收到一个分组时，将分组就从输入端口复制到存储器中，从    分组首部    提取   目的地址  ，查找路由表，再将分组复制到合适的  输出端口  的缓存中。</p>

<p>采用这种方式分组要两次经过系统的总线（一次写和 一次读），交换速度比较慢。</p>

<p>许多现代的低端路由器也通过存储器进行交换，与早期路由器的区别是   目的地址    的    查找   和    分组   在存储器中的缓存都是在    输入端口   中进行的。</p>

<p><img src="/assets/计算机网络.assets/fca97104ce8046e99190ffdd7c6fccd4.png" alt="img" /></p>

<p><strong>2. 经总线交换</strong></p>

<p>分组从  <em>输入端口</em>  通过  <em>共享的总线</em> 直接传送到合适的  输出端口，不需要路由选择处理机的干预。</p>

<p>但是，由于   总线是共享的，因此在同一时间只能有一 个分组在总线上传送。</p>

<p>当分组到达输入端口时，若发现总线忙，则被阻塞而不能通过交换结构，并在输入 端口排队等待。</p>

<p>路由器的转发带宽显然要<strong>受到总线速率的限制</strong>；</p>

<p>要想 <strong>实现无阻塞交换，交换总线的速率，就要大于所有输入端口速率的总和</strong>。</p>

<p>由于只经过一次总线，比通过存储器交换要快。</p>

<p><img src="/assets/计算机网络.assets/7f43eaa4d0d34d9cbbe349803be094a2.png" alt="img" /></p>

<p><strong>3. 经互联网络交换</strong></p>

<p>这 种 交 换 结构 常 称 为互连 网 络（Interconnection Network），它有2N条纵横交叉的总线，通过控制相应的交叉结点使水平总线和垂直总线接通还是断开， 将分组转发到合适的输出端口。</p>

<p>当输入端口收到一个分组时，就将它发送到与该输入 端口相连的水平总线上。若通向所要转发的输出端口 的垂直总线是空闲的，则在这个结点将垂直总线与水 平总线接通，然后将该分组转发到这个输出端口。</p>

<p>但若该垂直总线已被占用（有另一个分组正在转发到 同一个输出端口），则后到达的分组就被阻塞，必须 在输入端口排队。</p>

<p><img src="/assets/计算机网络.assets/b37bc5022f5644a2b36a4f55eb6661af.png" alt="img" /><em>**</em></p>

<h4 id="输出端口">输出端口</h4>

<p>​        把交换结构传送过来的分组先进行缓存。数据链路层处理模块将分组加上链路层的首部和尾部，交给物理层后发送到外部线路。</p>

<blockquote>
  <p>​    <strong>若从交换结构到达队列的分组速率超过链路的速率，则会导致输出队列排队！</strong></p>
</blockquote>

<h4 id="总结处理过程">总结处理过程</h4>

<ul>
  <li>
    <p>链路层解封装，IP头部校验。</p>
  </li>
  <li>
    <p>获取报文目的IP地址。</p>
  </li>
  <li>
    <p>用目的IP地址，基于<strong>最长前缀匹配</strong>规则查询转发表。</p>
  </li>
  <li>
    <p>查询失败，丢弃报文。</p>
  </li>
  <li>
    <p>查询成功：
获取转发出接口和下一跳IP地址。
IP头部“TTL”字段值减1，重新计算IP头部“校验和”。
重新进行链路层封装，发送报文。
注：普通IP报文转发过程中，路由器不查看传输层及以上层协议的内容。</p>
  </li>
  <li>
    <p>IP报文在路由器转发前后的变化：</p>

    <p>链路层封装更新，IP头部“TTL”减1，IP头部“校验和”更新。</p>
  </li>
  <li>
    <p>数据报在不同硬件单元的处理</p>

    <ul>
      <li>
        <p>报文输入的接口卡
链路层解封装
转发表查询（该工作在输入接口卡处理）
通过交换结构将报文排队发往目的接口卡（发送过快将产生拥塞）</p>
      </li>
      <li>
        <p>交换结构
从输入接口卡发往输出接口卡</p>
      </li>
      <li>
        <p>报文输出的接口卡
从交换结构接收报文（排队进行后续处理，到达太快将产生拥塞）
链路层封装
从输出接口发送报文</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="分组调度算法">分组调度算法</h4>

<p>排队的分组如何经输出链路传输？</p>

<p>1.先进先出（FIFO）
先来的先服务</p>

<p>2.优先权排队
比如分成普通用户和vip两个队，普通用户来了进普通用户队列，vip来了进vip队列，每种队列内通常是FIFO。</p>

<p>每个优先权类可以配置一个队列，每次从非空的优先权队列选择一个。</p>

<p>实践中网络操作员可以配置一个队列，这样携带网络管理信息的分组（比如通过源或目的TCP/UDP端口号所标识）能够比用户流量更有优先权。或者比如实时语音比电子邮件更具有优先权。要传输一个分组时从队列为非空的最高优先级中传输。分组传输时也不能被别的分组打断。</p>

<p>3.循环和加权公平排队
循环公平排队跟上一个相似，不同之处就是大家都是平等的，没有我是vip你不是这一说，循环着来，你这个队列没人了就找下一个。</p>

<p><strong>加权公平排队（WFQ）</strong>给每个类分配权重，即使是最坏情况下也就是每个队都有人，某个队依然能获得权重x总带宽</p>

<p>第i类将确保接收到的服务部分等于 $\huge \frac{w_i}{\sum{w_j}}$</p>

<p>被分配的带宽也是$\huge \frac{w_i}{\sum{w_j}}$</p>

<p>总吞吐量R 则被分配的吞吐量为$\huge R*\frac{w_i}{\sum{w_j}}$</p>

<h3 id="网际协议ipv4">网际协议——IPv4</h3>

<p>网际协议IP是TCP/IP体系中两个最主要的协议之一。</p>

<p><strong>主要功能：</strong>IP 协议是一个无连接的服务，负责在源地址和目的地址之间传送数据报，其主要功能就是把数据报在互连的网络上传送，将数据报在一个个模块间通过路由处理网络地址传送到目的地址。</p>

<blockquote>
  <p>（1）寻址
在不同网络中必须通过三层地址进行寻址。常用的IP网络中运行的三层协议就是 IP 协议，对应的三层地址就是 IP 地址。
（2） 数据报的封装
从传输层过来的数据段需要经过IP协议的重封装，而从数据链路层过来的数据帧就需要进行解封装。在IP网络中封装后形成的是IP数据报，IP封装的目的就是标识此IP数据报发送节点和接受节点的IP地址和控制信息。
（3）分段与重组
不同网络上的链路可以传输的最大报文大小是不同的，这就是我们通常说的MTU（最大传输单元）。尺寸较大的数据报在MTU值较小的网络链路传输需要将数据报分段依次传输，对应的接收方就需要把这些接收到的拆分的分段组合起来，还原成原来的数据报</p>
</blockquote>

<p>与IP协议配套使用的还有三个协议：地址解析协议 ARP、网际控制报文协议 ICMP 和网际组管理协议 IGMP。</p>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX19sZWFybmluZw==,size_16,color_FFFFFF,t_70.png" alt="img" /></p>

<h4 id="报文结构-1">报文结构</h4>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX19sZWFybmluZw==,size_16,color_FFFFFF,t_70-1705390906485-70.png" alt="在这里插入图片描述" /></p>

<blockquote>
  <p>● 版本：指定IP数据报中使用的IP协议版本，占4位。IPv4对应值为4（0100）
● 首部长度：指示IP数据报头部的总长度，占4位。IP数据报头部的总长度以4字节为单位（即4字节的整数倍）
● 区分服务：用于表示数据报的优先级和服务类型，占8位。包括一个3位长度的优先级，4位长度的标志位，最高位未用
● 总长度：标识整个IP数据报的总长度，包括报头和数据部分，占16位，由此可知IPv4的最大长度为65535（64KB）
● 标识：用于表示IP数据报的标识符，占16位，每个IP数据报有一个唯一的标识（不是序号）。当数据报分段时，这个标识的值就被复制到所有分段的标识字段中，相同的标识字段值使分段后的数据报分段最后能正确地重组成为原来的数据报。
● 标志：指出该IP数据报后面是否还有分段，为分段标志，占3位，仅最低位有意义
● 片偏移：指出该分段在数据报中的相对位置。相对于用户数据字段的起点，该字段从何处开始，占13位
● 生存时间：标识IP数据报在网络中传输的有效期，以秒来计数，占8位。现在通常认为这个数值是指数据报允许经过的路由器数，当值为0时，就丢弃这个数据报。设定生存时间是为了防止数据报在网络中无限制地循环转发。
● <strong>协议：</strong>用来标识此IP数据报在传输层所采用的协议类型（如TCP、UDP或ICMP等），以便使目的主机的IP层知道应将数据部分上交给哪个处理过程，占8位
● <strong>首部校验和：</strong>用来检验IP数据报的包头部分（不含“数据”部分）在传输到接收端后是否发生了变化，占16位。因为数据报每经过一个路由器，路由器都要重新计算一下报头校验和
● <strong>源地址/目的地址：</strong>分别表示该IP数据报发送者和接收者的IP地址，各占32位
● 可变部分：用来支持各种选项，提供扩展余地，可用来支持排错、测量以及安全等措施。后面的填充字段就是为了保证IP数据报的报头是32位的整数倍。</p>
</blockquote>

<h4 id="ip地址">IP地址</h4>

<p>每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号，host-id，它标志该主机（或路由器）。</p>

<blockquote>
  <p>● 网络号：保证相互连接的两个网段具有不同的标识, 简单来说就是标识网络 (网段:一段范围内的IP, 具体是网络号相同的所有IP)
● 主机号：同一网段内, 主机之间具有相同的网络号, 但是必须有不同的主机号, 简单来说就是标识同一网段下的不同主机
● 子网：IP 地址是以网络号和主机号来表示网络上的主机的, 只有在一个网络号下的计算机之间才能“直接”互通, 不同网络号的计算机要通过网关（Gateway）才能互通. 但这样的划分在大多数情况下显得并不十分灵活. 为此IP网络还允许划分成更小的网络, 称为子网（Subnet）</p>
</blockquote>

<p>通过合理的设置网络号和主机号，就可以保证在相互连接的网络中，每台主机的IP地址都不同。那么如何自动管理子网内的IP：</p>

<blockquote>
  <p>DHCP 动态主机配置协议 ：首先,这是一个应用层协议，可以自动给子网内新增的主机节点分配IP地址. 。一般的路由器都带有DHCP功能， 因此路由器也可以看做是一个DHCP服务器。</p>
</blockquote>

<p>IP 地址分为三类：A类、B类和C类</p>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX19sZWFybmluZw==,size_16,color_FFFFFF,t_70-1705391595323-73.png" alt="img" /></p>

<p>几个特殊的ip地址</p>

<blockquote>
  <p>① IP地址中的主机号全为0，就成了<strong>网络号</strong>，代表这个局域网
② 将IP地址中的主机号的二进制全部设为1，就成为了广播地址，用于给同一个链路中相互连接的所有主机发送数据包(此时目的地址当然就被设为了广播地址)
③ 127.0.0.1. 它代表设备的本地虚拟接口， 所以默认被看作是永远不会宕掉的接口。所以通常在安装物理网卡前就可以ping通这个本地回环地址。 一般都会用来检查本地网络协议、基本数据接口等是否正常的。
④ 0.0.0.0 标识本机上的所有网卡。用与TCP服务端程序的绑定地址，相当于监听本机的所有网卡。</p>

  <p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX19sZWFybmluZw==,size_16,color_FFFFFF,t_70-1705391723325-76.png" alt="在这里插入图片描述" /></p>
</blockquote>

<h4 id="划分子网">划分子网</h4>

<p>从两级 IP 地址到三级 IP 地址</p>

<p>在 ARPANET 的早期，IP 地址的设计不够合理：</p>

<blockquote>
  <p>● IP 地址空间的利用率有时很低。
● 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。
● 两级的 IP 地址不够灵活。</p>
</blockquote>

<p>早期 IP 地址的设计不合理产生了很多问题，为了解决这些问题 IP 地址中又增加了一个”子网号字段”，使两级的IP地址变成了三级的IP地址。</p>

<p><strong>（1）划分子网的基本思路：</strong></p>

<p>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网。</p>

<p>① 划分子网纯属一个单位内部的事情，对外部网络透明，单位对外仍然表现为没有划分子网的网络。</p>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX19sZWFybmluZw==,size_16,color_FFFFFF,t_70-1705392963832-79.png" alt="在这里插入图片描述" /></p>

<p>② 从主机号借用若干个位作为子网号 subnet-id，<strong>而主机号 host-id 也就相应减少了若干个位</strong>。于是两级 IP 地址变成了三级 IP 地址：网络号、子网号和主机号。</p>

<p><img src="/assets/计算机网络.assets/20210706181713948.png" alt="在这里插入图片描述" /></p>

<p><img src="/assets/计算机网络.assets/20210706181724463.png" alt="在这里插入图片描述" /></p>

<p>③ 凡是从其他网络发送给本单位某个主机的 IP 数据报，<strong>仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。</strong>
④ 最后就将 IP 数据报直接交付目的主机。</p>

<p>（2）划分子网后变成三级结构的优点</p>

<p>● 减少了 IP 地址的浪费
● 使网络的组织更加灵活
● 更便于维护和管理</p>

<h4 id="子网掩码">子网掩码</h4>

<p>（1）子网掩码</p>

<blockquote>
  <p>● 子网掩码是一个应用于 TCP/IP 网络的32位二进制值，每节 8 位，必须结合IP地址对应使用。 （常见的 255.255.255.0 等）
● <strong>子网掩码 32 位都与 IP 地址 32 位对应，如果某位是网络地址（网络号部分和子网号部分）则对应的位全为“1”，如果是主机号部分则对应的位全为“0”。(11111111.11111111.11111111.0)</strong>
● 子网掩码(subnet masking)的功能是告知主机或路由设备，地址的哪一部分是网络号，包括子网的网络号部分，哪一部分是主机号部分。
● 子网掩码可以分离出 IP 地址中的网络地址和主机地址，用于判断该 IP 地址是在局域网上，还是在广域网上。
● 子网掩码一般用于将网络进一步划分为若干子网，以避免主机过多而拥堵或过少而 IP 浪费。</p>
</blockquote>

<p>（2）子网掩码使用原因</p>

<p>从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分，因为 IP 地址本身及数据报的首部没有包含任何关于有关子网划分的信息。<strong>使用子网掩码 (subnet mask) 可以找出 IP 地址中的子网部分。</strong></p>

<p>（3）子网掩码是一个重要属性</p>

<blockquote>
  <p>● 子网掩码是一个网络或一个子网的重要属性。
● 路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。
● 路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。
● 若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</p>
</blockquote>

<p>（4）子网掩码的作用</p>

<p>子网掩码可以分离出 IP 地址中的网络地址和主机地址。当两台计算机要通讯，首先要判断是否处于同一个广播域（局域网）内，即网络地址（网络号）是否相同。<strong>如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地</strong>。</p>

<p>（5）默认子网掩码</p>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX19sZWFybmluZw==,size_16,color_FFFFFF,t_70-1705393096931-90.png" alt="在这里插入图片描述" /></p>

<p>（6）子网掩码的使用</p>

<p>● 网络号：<strong>IP地址和子网掩码进行与运算得到网络号</strong>。
● 子网号：子网掩码 32 位都与 IP 地址 32 位对应，如果某位是网络地址（网络号部分和子网号部分）则对应的位全为“1”，如果是主机号部分则对应的位全为“0”。将子网掩码中“1”的位数减去该类的默认子网掩码的“1”的位数即为子网号位数。
● 主机号：子网掩码取反再和 IP 地址做与运算得到主机号。</p>

<p>（7）子网掩码的使用例子</p>

<p>给定IP地址和子网掩码 172.31.128.255 / 18 （18 是网络地址（网络号和子网号的位数）的长度），则：</p>

<p>这个 IP 地址是 B 类地址，默认的子网掩码是255.255.0.0，所以该地址的网络号是16位。但是子网掩码中前 18 位为 1，也就是网络地址（网络号、子网号）有 18 位，则子网号有 14 位 。
● 网络号
公式：将 IP 地址的二进制和子网掩码的二进制进行“&amp;”（and）运算，得到的结果就是网络号。“&amp;运算”的规则是1&amp;1=1，0&amp;1=0，1&amp;0=0,0&amp;0=0。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">ip</span><span class="pi">:</span>         <span class="s">10101100.00011111.10000000.11111111</span>     

<span class="s">子网掩码:　　11111111.11111111.11000000.00000000</span> 
<span class="s">---------------------------------------------------</span>
<span class="na">网络号</span><span class="pi">:</span>     <span class="s">10101100.00011111.10000000.00000000   &amp;　</span>  
<span class="na">网络号点分法表示</span><span class="pi">:</span> <span class="s">172.31.128.0</span> 
</code></pre></div></div>

<p>● 主机号</p>

<p>公式：用IP地址的二进制和（子网掩码的二进制的反码）进行“&amp;”运算，得到的结果就是主机号。反码就是将原本是0的变为1，原本是1的变为0。</p>

<p>ip:           10101100.00011111.10000000.11111111</p>

<p>子网掩码取反:　00000000.00000000.00111111.11111111</p>

<p>主机号:       00000000.00000000.00000000.11111111   &amp;　
主机号点分法表示: 0.0.0.255</p>

<p>● 广播地址</p>

<p>公式：在得到网络号的基础上，将网络号右边的表示IP地址的主机部分的二进制位全部填上1，再将得到的二进制数转换为十进制数就可以得到广播地址。因为本题中子网掩码 11111111.11111111.11000000.00000000，
0 有14个，主机位是 14，我们将网络号 172.31.128.0，转换为二进制是 &gt;10101100.00011111.10000000.00000000，从右边数起，将 14 个 0 全部替换为 1， 即 &gt;10101100.00011111.10111111.11111111，这就是这个子网的广播地址的二进制表示法。将这个二进制广&gt;播地址转换为十进制就是 172.31.191.255。</p>

<p>网络号:     10101100.00011111.10000000.00000000</p>

<p>子网掩码:　　11111111.11111111.11000000.00000000</p>

<p>广播地址:   10101100.00011111.10111111.11111111   网络号从右向左0填为1，个数为掩码中的0
广播地址点分法表示: 172.31.191.255
● 可用IP地址范围</p>

<p>因为网络号是172.31.128.0，广播地址是172.31.191.255，所以子网中可用的IP地址范围就是从网络号+1 ~广播地址-1，所以子网中的可用IP地址范围就是从172.31.128.1-172.31.191.254。</p>

<p>（7）子网掩码如何确定</p>

<p>例: 学校新建 5 个机房，每个房间有 30 台机器，如果给定一个 C 类网络地址：192.168.1.0，问如何将其划分为5个子网，子网掩码该如何设置？</p>

<p>子网划分建议按以下步骤和实例计算子网掩码：</p>

<p>● 将要划分的子网数目转换为2的m次方。如要分8个子网，8=2^3。
● 取上述要划分子网数的幂m。如2^3，即 m = 3。
● 将上一步确定的幂m按高序占用主机地址m位后转换为十进制。
● 如m为3 则是 11100000，转换为十进制为224，即为最终确定的子网掩码。
● 如果是C类网，则子网掩码为255.255.255.224；如果是B类网，则子网掩码为255.255.224.0；如果是A类网，则子网掩码为255.224.0.0。</p>

<p>2^3=8（大于5的最小的2的整幂次数），则子网号有 3 位，就向主机号中借走三位作为网络号，而剩下的5位主机号，每个网段内可容纳的主机数是 2^5 即 32，可用主机需要再减 2 即为 30，满足每个房间30台机器的题目要求。取2^3的幂，即3，即占用了主机号中的高 3 位即为 11100000，转换为十进制为 224，所以该地址为 C 类地址的子网掩码应该设置为 255.255.255.224。各机房IP和子网掩码配置如下（已经去掉广播地址和主机地址）：</p>

<p>机房号        子网掩码                 IP地址范围</p>

<p>机房1     255.255.255.224     192.168.1.1~192.168.1.30</p>

<p>机房2     255.255.255.224     192.168.1.33~192.168.1.62</p>

<p>机房3     255.255.255.224     192.168.1.65~192.168.1.94</p>

<p>机房4     255.255.255.224     192.168.1.97~192.168.1.126</p>

<p>机房5     255.255.255.224     192.168.1.129~192.168.1.158</p>

<h4 id="dhcp">DHCP</h4>

<p><img src="/assets/计算机网络.assets/740dae5a20e527510eb9ed0fba0ecf74.png" alt="image-20220712115612974" /></p>

<ul>
  <li>0.0.0.0表示本机IP地址；255.255.255.255是广播地址；</li>
  <li>第一次主机发出的广播（发现报文），所有主机都可以接收到，但是只有DHCP服务器才会进行响应（提供报文）；
    <ul>
      <li>为该主机分配IP地址；</li>
      <li>yladdr就是DHCP服务器给该主机分配的IP地址；</li>
      <li>这个提供报文也是通过广播地址发出去的；</li>
    </ul>
  </li>
  <li>第二次主机发出的仍然是广播，也是告知其他的DHCP服务器已经跟现在的这个链接上了；（请求报文）；</li>
  <li>在DHCP服务器第二次回应之后，就确认绑定该IP地址的了；</li>
</ul>

<p><img src="/assets/计算机网络.assets/85c329841881b476c4171ad5b4e967a1.png" alt="image-20220712115706041" /></p>

<p><img src="/assets/计算机网络.assets/b66e511df66dbf18880a55c7410f6f7e.png" alt="image-20220712115724086" /></p>

<h3 id="网际协议ipv6">网际协议——IPv6</h3>

<p>新的子网和IP节点以惊人的增长率连接到因特网并被分配唯一的IP地址，32bit的IP地址空间即将用尽，为了应对这种情况开发了IPv6并且加强了IPv4。</p>

<h4 id="ipv6数据报格式">IPv6数据报格式</h4>

<p><img src="/assets/计算机网络.assets/8e770569c72845cb9069adc912e30787.png" alt="在这里插入图片描述" /></p>

<p><img src="/assets/计算机网络.assets/cc0587c81ae04222b84a1405517e371a.png" alt="在这里插入图片描述" /></p>

<blockquote>
  <ul>
    <li>扩大的地址容量。除了单播和多播地址以外，它还引入了一种称为任播地址的新型地址，这种地址可以使数据报交付给一组主机中的任意一个（例如可用于向一组包含给定文档的镜像站点的最近一个发送HTTP GET请求）</li>
    <li>简化高效的40字节首部。许多IPv4字段已被舍弃或或作为选项。因而形成的40字节定长首部允许路由器更快的处理IP数据报。一种新的选项编码允许进行更灵活的选项处理。</li>
    <li>流标签。IPv6有一个难以捉摸的流定义。该字段可用于“给特属于特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种非默认服务质量或需要实时服务的流”，比如音频和视频传输可能被认为是流，电子邮件传输就不会。高优先权用户（比如为使其流量得到更好的服务而付费的用户）承载的流量也有可能被当作一个流，可以看出即使没有一个十分精确的定义，但是设计者仍然考虑到了为了可能会出现的某种状况。</li>
    <li>版本。该4bit字段用于标识IP版本号，IPv6将该字段设为6（但是IPv4不是4 ）</li>
    <li>流量类型。该8bit字段与IPv4的TOS（服务类型）字段相似。</li>
    <li>有效载荷长度。这16bit是一个无符号整数，给出了IPv6数据报中跟在定长40字节首部后面的字节数量。</li>
    <li>下一个首部。标识数据字段需要交付给哪个协议（比如TCP啥的），这个字段使用与IPv4首部中协议字段相同的值。</li>
    <li>跳限制。类似于IPv4的寿命字段。</li>
    <li>源和目的地址。</li>
    <li>数据。这是IPv6数据报的有效载荷部分。</li>
  </ul>
</blockquote>

<p><strong>IPv6中没有的：</strong></p>

<p>分片和重新组装：IPv6不允许数据报在路由器中进行分片和组装，这个过程只能被源和目的地执行，如果一个路由器因为一个IPv6数据报太大而无法转发到链路上的话，路由器只需要扔掉它就好了并向发送方发送一个“你这个报太大了，拆小点再发给我”的ICMP差错报文即可。分组和重新组装非常耗时，这个系统从路由器中移到端系统中将会大大提高转发效率。
首部检验和。设计者可能认为在链路层和运输层都会检验那么在网络层又检验一遍多少有点多余于是就把它删掉了。如图分片和重组、计算跳限制（或者寿命字段）一样，路由器中执行计算首部检验和也很耗时。
选项。没有了这个字段，但是不一定消失，也可能会出现在下一个首部字段。删除选项字段使得IP首部称为定长的40字节。</p>

<p><strong>IPv4到IPv6的迁移</strong>
那么如果两个IPv6节点之间存在有IPv4节点那么怎么传输数据呢？我们把两个IPv6节点之间的IPv4节点集合称为隧道，当IPv6数据报到达IPv4节点后，只需要把IPv6数据报塞到IPv4数据报的有效载荷字段即可，然后正常传输。这些IPv4节点也不知道自己传的IPv4数据报中的数据字段包含有完整的IPv6数据报。穿过隧道后第一个IPv6节点通过查看IPv4数据报的协议号字段是41，指示该IPv4的有效载荷是IPv6数据报并把其取出，就好像是从一个直接相连的IPv6邻居那里接收到该IPv6数据报那样。
<img src="/assets/计算机网络.assets/image-20240116165735573.png" alt="image-20240116165735573" /></p>

<h3 id="通用转发和sdn">通用转发和SDN</h3>

<p>我们现在考虑一种更有意义的通用“匹配加动作”范式，其中能对协议栈多个首部字段进行匹配，这些首部字段是与不同层次的不同协议相关联的。</p>

<p>“动作”能够包括：将分组转发到一个或多个输出端口（就像在基于目的地转发中一样），跨越多个通向服务的离开接口进行负载均衡分组（就像在负载均衡中一样），重写首部值（就像在NAT中一样），有意识阻挡/丢弃某个分组（就像在防火墙中一样），为进一步处理和动作而向某个特定的服务器发送一个分组（就像在DPI一样）等等。</p>

<p>因为能够使用网络层和/或链路层源和目的地址做出转发决定，所以这种转发设备更为准确的描述为“分组交换机”而不是第三层“路由器”或是第二层“交换机”</p>

<p>每台分组交换机又一张匹配加动作表，通过远程控制计算、安装和更新。在各台分组交换机中的控制组件可以相互作用，但是实践中通用匹配加动作能力是通过计算、安装和更新这些表的远程控制器实现的。</p>

<p>我们主要考虑OpenFlow1.0，该标准以特别清晰和简明的方式引入了关键的SDN抽象和功能。</p>

<p>匹配加动作转发表在OpenFlow中称为流表，它的每个表项包括：</p>

<p>首部字段值的集合，如分组将与之匹配。基于硬件匹配在TCAM内存中执行的最为迅速（TCAM内存中可能有上百万条地址表项）。匹配不上流表项的分组将被丢弃或者发送到远程控制器做更多处理。
计数器集合（当分组与流表项匹配时更新计数器）。这些计数器可以包括已经与该表项匹配的分组数量以及自从该表项上次更新以来的时间。
当分组匹配流表项时所采取的动作集合。这些动作可能将分组转发到给定的输出端口，丢弃该分组、复制该分组和将它们发送到多个输出端口，和/或重写所选的首部字段。
流表本质上是一个API，通过这种抽象每台分组交换机的行为能够被编程。</p>

<h4 id="匹配">匹配</h4>

<p>OpenFlow的匹配抽象允许对来自三个层次的协议首部所选择的字段进行匹配。</p>

<p>流表项可以有通配符。每个流表项也有相应的优先权，如果一个分组匹配多个流表项，选定的匹配和对应的动作将是其中有最高优先权的那个。</p>

<p>并不是一个IP首部中的所有字段都能被匹配，如果匹配所有就会显得过于臃肿，这种抽象化的处理也就没有什么意义了。</p>

<h4 id="动作">动作</h4>

<p>每个流表项都有零个或多个动作列表，这些动作决定了应用于与流表项匹配的分组的处理。如果有多个动作，它们以在表中规定的次序执行。</p>

<p>其中最为重要的动作可能是：</p>

<p>转发。一个入分组可以转发到一个特定的物理输出端口，广播到所有端口（除了该分组的到达端口），或通过所选的端口集合进行多播。该分组可能被封装并发送到用于该设备的远程控制器。该控制器可能（或可能不）对该分组采取某些动作，包括安装新的流表项，以及可能将该分组返回给该设备以在更新的流表桂萼集合下进行转发。
丢弃。没有动作的流表项表明某个匹配的分组应该被丢弃。
修改字段。在分组被转发到所选输出端口之前，分组首部十个字段（除IP协议字段外的所有第二、三、四层的字段）中的值可以重写。</p>

<h3 id="控制平面">控制平面</h3>

<p>完成转发表和流表的工作有两种可能的方法：</p>

<ul>
  <li><strong>路由器控制：</strong>每台路由器中都包含转发和路由选择功能，每台路由器都有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值。</li>
  <li><strong>逻辑集中式控制：</strong>通用的“匹配加动作”抽象允许执行传统的IP转发以及其他功能（负载共享、防火墙功能和NAT）的丰富集合，而这些功能先前是在单独的中间盒实现的 。</li>
</ul>

<p>该控制器经一种定义良好的协议与每台路由器中的一个控制代理（CA）进行交互。以配置和管理该路由器的转发表。CA一般具有最少的功能，其任务是与控制器通信并且按控制器命令行事。CA这里的交互是被动的，也就是说不同CA不能直接相互交互和主动参与计算转发表。这是和前者的关键差异。</p>

<h4 id="路由选择算法">路由选择算法</h4>

<p>用图G = ( N , E ) 来描述路由选择问题，是一个N个节点和E条边的集合，其中每条边是取自N的一对节点。节点表示路由器，这是做出分组转发决定的点；连接这些节点的边表示这些路由器之间的物理链路。一条边还有一个值表示它的开销，用c（x，y）表示节点x和y之间的开销，并且这里讨论的是无向图。如果x和y都属于E，那么x也被称为y的邻居。</p>

<p>路由是最低开销路径是找出源与目的地之间具有最低开销的一条路</p>

<blockquote>
  <ul>
    <li>较好路径：按照某种指标较小的路径</li>
    <li>指标：站数，延迟，费用，队列长度等，或者是一些单纯指标的加权平均</li>
    <li>采用什么样的指标，表示网络使用者希望网络在什么方面表现突出，什么指标网络使用者比较重视</li>
  </ul>
</blockquote>

<p><strong>分类方式：</strong>一般而言，路由选择算法的一种分类方式是根据该算法是集中式还是分散式来划分的。</p>

<p><strong>集中式路由选择算法</strong>用完整的、全局性的网络知识计算出从源到目的地之间的最低路径开销。也就是说该算法以所有节点之间的连通性及所有链路的开销为输入。主要区别在于集中式算法具有关于连通性和链路开销方面的完整信息。具有全局状态的算法被称为链路状态（LS）算法，因为该算法得知道网络中具体每条路径的开销。
<strong>在分散式路由选择算法中</strong>，路由器以迭代、分布式的方式计算出最低开销路径。<strong>没有节点拥有全部的网络链路开销的完整信息。</strong>相反，每个节点仅有与其直接相连的链路的开销知识即可开始工作。通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。
第二种广义分类方式是根据算法是<strong>动态</strong>的还是<strong>静态</strong>的。静态路由选择算法中路由随时间变化非常缓慢，通常是人工进行调整。动态路由选择算法随着网络流量负载或拓补发生变化而改变路由选择路径。一个动态算法可周期性的运行或直接响应拓补或链路开销的变化而运行。</p>

<p>第三种分类方式是根据它是<strong>负载敏感</strong>的还是<strong>负载迟钝</strong>的进行划分。在负载敏感算法中，链路开销会动态地变化以反映出底层链路的当前拥塞水平。当前的因特网路由选择算法都是负载迟钝的，因为某条链路的开销不明确的反映其当前或最近的拥塞水平。</p>

<h4 id="链路状态路由算法link-state">链路状态路由算法：link state</h4>

<h5 id="迪杰斯特拉算法">迪杰斯特拉算法</h5>

<p>迪杰斯特拉（Dijkstra）算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展（广度优先搜索思想），直到扩展到终点为止。</p>

<h5 id="ls路由的工作过程">LS路由的工作过程</h5>

<p>各点通过各种渠道获得整个网络拓扑，网络中所有链路代价等信息（这部分和算法没关系，属于协议和实现）
就是说每个点都得到了除去自己点的所有点到邻居点的路径信息</p>

<p>使用LS路由算法，计算本站点到其它站点的最优路径(汇集树)，得到路由表</p>

<p>按照此路由表转发分组(datagram方式)</p>

<blockquote>
  <ul>
    <li>严格意义上说不是路由的一个步骤</li>
    <li>分发到输入端口的网络层</li>
  </ul>
</blockquote>

<p><img src="/assets/计算机网络.assets/1fea8e3139bb412a93f9eb20a59a86f4.png" alt="在这里插入图片描述" /></p>

<p>具体过程</p>

<ol>
  <li>发现相邻节点,获知对方网络地址</li>
  <li>测量到相邻节点的代价(延迟,开销)</li>
  <li>组装一个LS分组,描述它到相邻节点的代价情况</li>
  <li>将分组通过扩散的方法发到所有其它路由器以上4步让每个路由器获得拓扑和边代价</li>
  <li>通过<code class="language-plaintext highlighter-rouge">Dijkstra</code>算法找出最短路径（这才是路由算法）</li>
</ol>

<h4 id="距离向量路由算法distance-vector-routing">距离向量路由算法：distance vector routing</h4>

<h5 id="动态规划算法">动态规划算法</h5>

<p>由动态规划方程（策略），将每次的选择带入最终得到结果，详细可以自行查阅</p>

<h5 id="基本思路">基本思路</h5>

<ul>
  <li>各路由器维护一张路由表,结构如图(其它代价) ，维护全部的节点
<img src="/assets/计算机网络.assets/a3d55589f1fb495ba2195f5a6d73bf20.png" alt="在这里插入图片描述" /></li>
  <li>各路由器与相邻路由器交换路由表(待续)</li>
  <li>根据获得的路由信息,更新路由表(待续)</li>
</ul>

<h5 id="具体过程">具体过程</h5>

<ul>
  <li>
    <p>每个节点都将自己的距离矢量估计值传送给邻居，定时或者DV有变化时，让对方去算</p>
  </li>
  <li>
    <p>当x从邻居收到DV时，自己运算，更新它自己的距离矢量 , 采用B-F equation:</p>

    <p>Dx(y) ← minv{c(x,v) + Dv(y)} 对于每个节点y ∊ N</p>

    <p>X往y的代价 x到邻居v代价 v声称到y的代价</p>
  </li>
  <li>
    <p>Dx(y)估计值最终收敛于实际的最小代价值dx(y)，分布式、迭代算法</p>
  </li>
</ul>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWJ55yL5LiN54K56LWe,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述" /></p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWJ55yL5LiN54K56LWe,size_10,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述" /></p>

<h5 id="特点">特点</h5>

<blockquote>
  <p><strong>好消息传的快 坏消息传的慢</strong></p>
</blockquote>

<p><strong>好消息传的快</strong>
类似于当链路可同通过每一次的迭代更新至全网是非常容易的，已经时正向的在更新</p>

<p><strong>坏消息传的慢</strong>
当某一时刻起始点到某个点的链路断掉，又是因为迭代问题我们需要从头开始往后更新信息说链路断了，但是此时后面的节点到起始点的代价都是有值状态，当迭代更新到起始点的第二个节点时发现断了准备更新数值，这时第三个点告诉他兄弟我这条到起始点的路没断你就更新成我的代价吧，其实这个时候由于迭代的问题后面的点压根不知道前面是断的，导致了信息错误。</p>

<h4 id="lsdv算法对比">LS、DV算法对比</h4>

<p><img src="/assets/计算机网络.assets/image-20240116172927752.png" alt="image-20240116172927752" /></p>

<h4 id="因特网自治系统内部路由选择ospf">因特网自治系统内部路由选择——OSPF</h4>

<h5 id="概述">概述</h5>

<ul>
  <li>
    <p>“open”：标准可公开获得</p>
  </li>
  <li>
    <p>使用LS算法</p>

    <ul>
      <li>
        <p>LS分组在网络中（一个AS内部）分发</p>
      </li>
      <li>
        <p>全局网络拓扑、代价在每一个节点中都保持</p>
      </li>
      <li>
        <p>路由计算采用Dijkstra算法</p>
      </li>
    </ul>
  </li>
  <li><strong>OSPF通告信息中携带:每一个邻居路由器一个表项</strong></li>
  <li>通告信息会传遍AS全部（通过泛洪）</li>
  <li><strong>在IP数据报上直接传送OSPF报文(而不是通过UDP和TCP，这跟RIP有不同)</strong></li>
</ul>

<h5 id="ospf-高级-特性">OSPF “高级” 特性</h5>

<ul>
  <li>安全:所有的OSPF报文都是经过认证的(防止恶意的攻击)</li>
  <li>允许有多个代价相同的路径存在(在RIP协议中只有一个)</li>
  <li>对于每一个链路，对于不同的TOS有多重代价矩阵</li>
</ul>

<blockquote>
  <p>例如:卫星链路代价对于尽力而为的服务代价设置比较低，对实时服务代价设置的比较高
支持按照不同的代价计算最优路径，如:按照时间和延迟分别计算最优路径</p>
</blockquote>

<ul>
  <li>
    <p>对单播和多播的集成支持:</p>

    <blockquote>
      <p>Multicast OSPF(MOSPF)使用相同的拓扑数据库，就像在OSPF中一样</p>
    </blockquote>
  </li>
  <li>
    <p>在大型网络中支持层次性OSPF</p>
  </li>
</ul>

<h5 id="层次化的ospf路由">层次化的OSPF路由</h5>

<p>2个级别的层次性：本地，骨干
链路状态通告仅仅在本地区域Area范围内进行
每一个节点拥有本地区域的拓扑信息;关于其他区域，知道去它的方向，通过区域边界路由器（最短路径）
区域边界路由器：“汇总（聚集）”到自己区域内网络的距离，向其它区域边界路由器通告.
骨干路由器：仅仅在骨干区域内，运行OSPF路由
边界路由器：连接其它的AS’s.</p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWJ55yL5LiN54K56LWe,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述" /></p>

<h4 id="isp之间路由选择bgp">ISP之间路由选择——BGP</h4>

<h5 id="层次路由">层次路由</h5>

<p><strong>1.1 平面路由概述</strong>
一个网络中的所有路由器的地位一样
通过LS,DV，或者其他路由算法，所有路由器都要知道其他所有路由器（子网）如何走
所有路由器在一个平面
<strong>1.2 平面路由的问题</strong>
规模巨大的网络中，路由信息的存储、传输和计算代价巨大
DV：距离矢量很大，且不能够收敛
LS：几百万个节点的LS分组的泛洪传输，存储以及最短路径算法的计算
管理问题:
不同的网络所有者希望按照自己的方式管理网络
希望对外隐藏自己网络的细节
当然，还希望和其它网络互联
<strong>1.3 层次路由</strong>
<strong>将互联网分成一个个AS(路由器区域)</strong>
某个区域内的路由器集合，自治系统“autonomous systems” (AS)
一个AS用AS Number（ASN) 唯一标示
一个ISP可能包括1个或者多个AS
<strong>路由变成了: 2个层次路由</strong>
AS内部路由：在同一个AS内路由器运行相同的路由协议
“intra-AS” routing protocol：内部网关协议
不同的AS可能运行着不同的内部网关协议
<strong>能够解决规模和管理问题</strong>
如：RIP,OSPF,IGRP
网关路由器：AS边缘路由器，可以连接到其他AS
AS间运行AS间路由协议
“inter-AS” routing protocol：外部网关协议
解决AS之间的路由问题，完成AS之间的互联互通
<strong>1.4 层次路由的优点</strong>
<strong>1.4.1 解决了规模问题</strong>
内部网关协议解决：AS内部数量有限的路由器相互到达的问题, AS内部规模可控
如AS节点太多，可分割AS，使得AS内部的节点数量有限
AS之间的路由的规模问题
增加一个AS，对于AS之间的路由从总体上来说，只是增加了一个节点=子网（每个AS可以用一个点来表示）
对于其他AS来说只是增加了一个表项，就是这个新增的AS如何走的问题
扩展性强：规模增大，性能不会减得太多
<strong>1.4.2 解决了管理问题</strong>
各个AS可以运行不同的内部网关协议
可以使自己网络的细节不向外透露</p>

<h5 id="互联网as间路由bgp">互联网AS间路由：BGP</h5>

<blockquote>
  <p>前面我们采用层次路由的办法来解决节点数量过多导致的效率下降问题，那么在层次路由划分为无数个AS后，这些大的AS应该采用什么协议来通信呢，这时BGP就应运而生</p>

  <ul>
    <li><strong>使用TCP协议报文传输</strong></li>
  </ul>
</blockquote>

<h6 id="bgp报文">BGP报文</h6>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWJ55yL5LiN54K56LWe,size_16,color_FFFFFF,t_70,g_se,x_16-1705399011440-3.png" alt="img" /></p>

<h6 id="bgp概述">BGP概述</h6>

<p>BGP (Border Gateway Protocol)：自治区域间路由协议“事实上的”标准
“将互联网各个AS粘在一起的胶水”</p>

<p><strong>BGP 提供给每个AS以以下方法：</strong></p>

<blockquote>
  <p>e（外部）BGP： 从相邻的ASes那里获得子网可达信息
i（内部）BGP： 将获得的子网可达信息传遍到AS内部的所有路由器</p>

  <p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWJ55yL5LiN54K56LWe,size_16,color_FFFFFF,t_70,g_se,x_16-1705399135434-6.png" alt="在这里插入图片描述" /></p>

  <p>根据子网可达信息和策略来决定到达子网的“好”路径</p>
</blockquote>

<ul>
  <li>允许子网向互联网其他网络通告“我在这里”</li>
  <li>基于距离矢量算法（路径矢量）</li>
</ul>

<blockquote>
  <p>不仅仅是距离矢量，还包括到达各个目标网络的详细路径（AS 序号的列表）能够避免简单DV算法的路由环路问题</p>
</blockquote>

<h5 id="bgp基础">BGP基础</h5>

<ul>
  <li>BGP 会话： 2个BGP路由器(“peers”)在一个半永久的<code class="language-plaintext highlighter-rouge">TCP</code>连接上交换BGP报文:</li>
</ul>

<blockquote>
  <p>通告向不同目标子网前缀的“路径”（BGP是一个“路径矢量”协议）</p>
</blockquote>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWJ55yL5LiN54K56LWe,size_16,color_FFFFFF,t_70,g_se,x_16-1705404768488-9.png" alt="在这里插入图片描述" /></p>

<h5 id="基于策略的路由">基于策略的路由：</h5>

<p>当一个网关路由器接收到了一个路由通告, 使用输入策略来接受或过滤（accept/decline.）
过滤原因例1：不想经过某个AS，转发某些前缀的分组
过滤原因例2：已经有了一条往某前缀的偏好路径
策略也决定了是否向它别的邻居通告收到的这个路由信息</p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWJ55yL5LiN54K56LWe,size_16,color_FFFFFF,t_70,g_se,x_16-1705404837361-12.png" alt="在这里插入图片描述" /></p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWJ55yL5LiN54K56LWe,size_16,color_FFFFFF,t_70,g_se,x_16-1705404846246-15.png" alt="在这里插入图片描述" /></p>

<h5 id="bgp-路径选择">BGP 路径选择</h5>

<p>路由器可能获得一个网络前缀的多个路径，路由器必须进行路径的选择，路由选择可以基于：</p>

<blockquote>
  <p>本地偏好值属性: 偏好策略决定
最短AS-PATH ：AS的跳数
最近的NEXT-HOP路由器：热土豆路由
附加的判据：使用BGP标示</p>
</blockquote>

<p>一个前缀对应着多种路径，采用消除规则直到留下一条路径</p>

<h6 id="热土豆策略">热土豆策略</h6>

<ul>
  <li>2d通过iBGP获知，它可以通过2a或者2c到达X</li>
</ul>

<blockquote>
  <p>选择具备最小内部区域代价的网关作为往X的出口（如：2d选择2a，即使往X可能有比较多的AS跳数）：不要操心域间的代价！</p>

  <p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWJ55yL5LiN54K56LWe,size_16,color_FFFFFF,t_70,g_se,x_16-1705404950629-18.png" alt="在这里插入图片描述" /></p>
</blockquote>

<h5 id="为什么内部网关协议和外部网关协议如此不同">为什么内部网关协议和外部网关协议如此不同?</h5>

<p>1 策略
Inter-AS（内部）： 管理员需要控制通信路径，谁在使用它的网络进行数据传输；
Intra-AS（外部）： 一个管理者，所以无需策略;
AS内部的各子网的主机尽可能地利用资源进行快速路由</p>

<p>2 规模
AS间路由必须考虑规模问题，以便支持全网的数据转发
AS内部路由规模不是一个大的问题
如果AS 太大，可将此AS分成小的AS；规模可控
AS之间只不过多了一个点而已
或者AS内部路由支持层次性，层次性路由节约了表空间, 降低了更新的数据流量
3 性能
Intra-AS： 关注性能
Inter-AS： 策略可能比性能更重要</p>

<h2 id="第五章网络链路层">第五章网络链路层</h2>

<h3 id="链路层概述">链路层概述</h3>

<p>据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p>

<p>我们将运行链路层协议的任何设备均称为<strong>节点</strong>。节点包括主机、路由器、交换机和WiFi接入点。我们也把沿着通信路径连接相应节点的通信信道称为<strong>链路</strong>。在通过特定的链路时，传输节点将数据报封装在<strong>链路层帧</strong>中，并将该帧传送到链路中。</p>

<p>使用链路层协议，将IP数据报通过单一通信链路 从一个节点移动到相邻节点</p>

<p><strong>链路层协议能够提供的可能的服务包括：</strong></p>

<p>数据链路层的基本任务是将源机器中来自网络层的数据传输到目标机器的网络层</p>

<ul>
  <li>
    <p><strong>成帧：</strong>把网络层数据报和一些首部字段封装成帧。</p>

    <blockquote>
      <ul>
        <li>封装成帧就是在一段数据前后添加首部和尾部，然后就构成了一个帧</li>
        <li>首部和尾部的重要作用就是进行帧定界</li>
      </ul>

      <p><img src="/assets/计算机网络.assets/image-20240116205105921.png" alt="image-20240116205105921" /></p>
    </blockquote>
  </li>
  <li>
    <p><strong>链路接入：</strong> <strong>媒体访问控制（MAC）</strong>协议规定了帧在链路上的传输规则。在点对点电路中（只有一个发送方和一个接收方）MAC的协议较简单（或者不存在），即无论何时链路空闲，发送方都能够发送帧。当多个节点共享单个广播链路时，MAC用于协调多个节点的帧传输。</p>
  </li>
  <li>
    <p><strong>可靠交付：</strong>当链路层协议提供可靠交付服务时，它保证无差错的经链路层移动每个网络层数据报。与运输层类似，通过确认和重传取得。链路层的可靠交付通常用于易于产生高差错的率的链路，例如无线链路，其目的是本地（也就是在差错发生的链路上）纠正一个差错，而不是通过运输层或者应用层协议迫使进行端到端的数据重传。对于低比特的差错的线路（一般是有线线路）链路层可靠交付一般会认为是一种不必要的开销，所以一般不提供。</p>
  </li>
  <li>
    <p><strong>差错检测和纠正：</strong>许多链路层协议提供一种机制来检测这种比特差错。通过让发送节点在帧中包括差错检验比特，让接收节点进行差错检查。链路层的差错检测通常更复杂并且用硬件实现。接收方还拥有检错和纠错功能。</p>
  </li>
</ul>

<h3 id="链路层在何处实现">链路层在何处实现</h3>

<p>链路层是实现在路由器中的线路卡中的。那么在主机上呢？链路层的主体部分是在网络适配器中实现的，网络适配器有时也称为网络接口卡（NIC）。位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务的专用芯片。因此，链路层控制器的许多功能是由硬件实现的。</p>

<p>在发送端，控制器取得了由协议栈较高层生成并储存在主机内存中的数据报，在链路层帧中封装该数据报（填写各个字段），然后遵循链路接入协议将该帧传进通信链路中。在接收端，控制器接受了整个帧，抽取出网络层数据报。如果链路层执行了差错检测，则需要发送控制器在该帧的首部设置差错检测比特，由接受控制器执行差错检测。</p>

<p>链路层是硬件和软件的结合体，即此处是协议栈中软件和硬件交接的地方。</p>

<p><img src="/assets/计算机网络.assets/5bf2218375074e248fd399da68a47dd7.png" alt="img" /></p>

<h3 id="解决透明帧问题">解决透明帧问题</h3>

<blockquote>
  <p><strong>什么是透明传输？</strong></p>

  <p><strong>透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。</strong>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p>

  <p><strong>为什么要组帧？</strong></p>

  <p>数据链路层之所以要把比特组合成帧为单位传输，是为了在出错时只重发出错的帧，而不必重发全部数据，从而提高效率。为了使接收方能正确地接收并检查所传输的帧，发送方必须依据一定的规则把网络层递交的分组封装成帧（称为组帧)。组帧主要解决<strong>帧定界、帧同步、透明传输</strong>等问题。</p>
</blockquote>

<p>组帧的方法（解决透明帧问题）：</p>

<p><strong>字符填充法</strong></p>

<p>字符填充法使用特定字符来定界一帧的开始与结束，在下面例子中，控制字符SOH放在帧的最前面，表示帧的首部开始，控制字符EOT表示帧的结束。为了使信息位中出现的特殊字符不被误判为帧的首尾定界符，可在特殊字符前面填充一个转义字符(ESC)来加以区分，以实现数据的透明传输。</p>

<p>接收方收到转义字符后，就知道其后面紧跟的是数据信息，而不是控制信息。因此会自己删除这个插入的ESC字符，结果仍得到原来的数据[见图3.4(c)]。</p>

<p>注意：转义字符是ASCII码中的控制字符，是一个字符，而非“E”“S”“C”三个字符的组合；如果转义字符 ESC也出现在数据中，那么解决方法仍是在转义字符前插入一个转义字符。</p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2lrb2tpbmd6eg==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" /></p>

<h3 id="差错检测和纠正技术">差错检测和纠正技术</h3>

<p>本节中我们研究几种简单的检测比特差错的技术，并在某些情况下能够纠正差错。</p>

<p>在发送节点，为了保护比特免受差错，使用差错检测和纠正比特（EDC）来增强数据D。通常要保护的数据不止数据字段，还包括首部字段，D和EDC都被发送到接收端，接受到比特序列D’和EDC’（可能与初始不同）。差错检测和纠错技术越复杂导致的开销越大（检测不出来差错的概率越小），也就意味着需要更多的计算量和差错检测和纠错比特。下面我们学习三种技术。</p>

<h4 id="奇偶校验">奇偶校验</h4>

<h5 id="单个奇偶校验位">单个奇偶校验位</h5>

<ul>
  <li>
    <p>对d比特的数据序列D，附加1位校验比特；</p>
  </li>
  <li><strong>偶校验方案</strong>
 发送方选择校验位的值使得d+1位比特序列中1的个数为偶数；
 接收方检测d+1位比特序列中的1个数是否为偶数，非偶数则认为出错；</li>
  <li>
    <p><strong>奇校验方案</strong>
 发送方选择校验位的值使得d+1位比特序列中1的个数为奇数；
 接收方检测d+1位比特序列中的1个数是否为奇数，非奇数则认为出错；</p>
  </li>
  <li>奇偶校验可检出所有奇数个比特差错的情况；</li>
  <li>若单个比特差错的概率低，且各个比特的差错事件独立，则奇偶校验是可接受的；</li>
  <li>事实上，差错经常以突发的方式聚集，即各个比特的差错事件是不独立的；</li>
</ul>

<h5 id="二维奇偶校验">二维奇偶校验</h5>

<p><img src="/assets/计算机网络.assets/image-20240116213913674.png" alt="image-20240116213913674" /></p>

<ul>
  <li>
    <p>将d位数据序列划分为i行j列矩阵，对每行每列计算奇偶校验值，共i+j+1个奇偶校验比特；</p>
  </li>
  <li>对单比特差错，二维奇偶校验可定位出错的行列并纠正之；
 事实上，发生在不相关行列上的多个单比特差错也可纠正；</li>
  <li>二维奇偶校验可以检测同一分组中两个比特差错的任意组合；</li>
</ul>

<p>接收方检测和纠正差错能力被称为前向纠错（FEC）。这些技术通常用于如音频CD这样的音频储存和回放设备中。在网络环境中，FEC技术可以单独应用，或与链路层ARQ技术(自动重传)一起应用。FEC技术可以减少所需的发送方重发的次数，也允许在接收方立即纠正差错。FEC避免了不得不等待的往返时延，而这些时延是发送方收到NAK分组并向接收方重传分组所需要的，这对于实时网络应用或者具有长传播时延的链路可能是一种非常重要的优点。</p>

<h4 id="检验和技术checksum">检验和技术(checksum)</h4>

<p>通常更多的应用于运输层。</p>

<p>数据的字节被作为16比特的整数对待并求和，这个和的反码形成了携带在报文段首部的因特网检验和。接收方通过对接受的数据（包括检验和）的和取反码，并且检测其结果是否全为1来检测检验和，如果这些比特中有任何是0，就可以指示出差错。</p>

<h5 id="因特网检验和">因特网检验和</h5>

<ul>
  <li>将数据序列视为16比特的整数序列并求和，将和的反码作为因特网检验和；</li>
  <li>接收方将整个数据序列（原数据和检验和）视为16比特整数序列并求和取反码，若结果全1则认为无差错；</li>
  <li>TCP和UDP中，对所有字段（分组头和分组载荷）计算检验和
 XTP协议对首部和整个分组（分组头和分组载荷）分别计算检验和</li>
</ul>

<p><img src="/assets/计算机网络.assets/image-20240116214358761.png" alt="image-20240116214358761" /></p>

<h4 id="循环冗余检测crc">循环冗余检测(CRC)</h4>

<p>CRC编码也成为多项式编码，因为该编码能够将要发送的比特串看作系数为0和1的一个多项式，对比特串的操作被解释为多项式算术</p>

<p>循环冗余码(Cyclic Redundancy Code，CRC)又称多项式码。</p>

<p>Q1：给定一个多项式G(X)，如何计算其对应的二进制位串呢？</p>

<p>A1：任何一个由二进制数位串组成的代码都可以与一个只含有0和1两个系数的多项式建立对应关系。一个k位帧可以视为从到的k次多项式的系数序列。</p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2lrb2tpbmd6eg==,size_20,color_FFFFFF,t_70,g_se,x_16-1705413463456-28.png" alt="img" /></p>

<p>Q2：如何计算循环冗余码？</p>

<p>A2：给定一个m bit的帧或报文,发送器生成一个r bit的序列，称为帧检验序列(FCS)。这样所形成的帧将由m+r比特组成。发送方和接收方事先商定一个多项式G(X)(最高位和最低位必须为1)，使这个带检验码的帧刚好能被预先确定的多项式G(X)整除。接收方用相同的多项式去除收到的帧，如果无余数，那么认为无差错。</p>

<p>注意：FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速， 因此不会延误数据的传输</p>

<p><img src="/assets/计算机网络.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2lrb2tpbmd6eg==,size_20,color_FFFFFF,t_70,g_se,x_16-1705413418915-25.png" alt="img" /></p>

<h3 id="多路访问控制mac协议">多路访问控制（MAC）协议</h3>

<p><strong>点对点链路：</strong>由链路一端的单个发送方和链路另一端的单个接收方组成。许多链路层协议都是为点对点链路设计的，如点对点协议（point - to - point protocol，PPP）、高级数据链路控制（high-level data link conltrol，HDLG）就是两种这样的协议。</p>

<p><strong>广播链路：</strong>它能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。以太网和无线局域网是广播链路层技术的例子。</p>

<p><strong>单一共享广播信道</strong>，两个或者两个以上结点同时传输将会相互干扰(interference)，冲突(collision)， 结点同时接收到两个或者多个信号导致</p>

<p><strong>多路访问控制协议(multiple access control protocol):</strong> 采用分布式算法决定结点如何共享信道，即决策结点何时可以传输数据，必须基于信道本身，通信信道共享协调信息!</p>

<p><strong>多路访问问题：</strong>如何协调多个发送和接收节点对一个共享广播信道的访问，这就是多路访问问题。</p>

<blockquote>
  <p>注意</p>

  <p>广播信道通常位于局域网中，局域网是一个地理位置上集中在一座建筑物中的网络。如一个公司、一所大学。
多路访问链路应该就是广播链路</p>
</blockquote>

<p>这些年来，在大量的链路层技术中已经实现了几十种多路访问协议。尽管如此，我们能够将任何多路访问协议划分为 3 种类型之一：<strong>信道划分协议，随机接入协议，轮流协议。</strong></p>

<p>假定在理想条件下。对于速率为Rbps的广播信道，多路访问协议应该具有以下特性：</p>

<p>1） 当仅有一个节点发送数据时，该节点具有Rbps的吞吐量。
2） 当有M个节点发送数据时，每个节点吞吐量为R/Mbps。（非瞬时，而是在一段时间内的平均值）
3） 协议是分散的，也就是说不会因某个节点故障而使得整个系统崩溃。
4） 协议是简单的，实现不贵。</p>

<h4 id="信道划分channel-partitioningmac协议">信道划分(channel partitioning)MAC协议</h4>

<ul>
  <li>多路复用技术</li>
  <li>VTDMA、FDMA、CDMA、WDMA等</li>
</ul>

<p>再来看看频分多路复用（FDM）,它将Rbps信道划分为不同的频段，每个频段具有R/N带宽，并把每个频率分配个N个节点中的一个，但是缺陷和上一种类似。</p>

<p>还有一种信道划分协议叫做码分多址（CDMA）对每一个节点分配一种不同的编码，然后每个节点用它唯一的编码来对它发送的数据进行编码，这个方法能实现同时接收而不产生干扰，具体后面会讲。</p>

<h5 id="时分多路复用tdm">时分多路复用（TDM）：</h5>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjM1MTU5Mw==,size_16,color_FFFFFF,t_70#pic_center.jpeg" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ux7R3pm8-1617844005112)(/Users/mac/Desktop/计算机网络/blog/第6章 链路层和局域网/12.jpg)]" /></p>

<p>假设一个支持N 个节点的信道且信道的传输速率为R bps。TDM将时间划分为时间帧(time frame)，并进一步划分每个时间帧为N个时隙 (slot)，然后把每个时隙分配给N 个节点中的一个。无论何时某个节点在有分组要发送的时候，它在循环的TDM帧中指派给它的时隙内传输分组比特。通常，选择的时隙长度应使一个时隙内能够传输单个分组。</p>

<p>TDM消除了碰撞而且非常公平，每个节点在每个帧时间内得到了专用的传输速率R/N bps。</p>

<p><strong>然而有两个缺陷：</strong></p>

<ul>
  <li>
    <p>节点被限制于R/N bps的 平均速率，即使当它是唯一有分组要发送的节点时。</p>
  </li>
  <li>
    <p>节点必须总是等待它在传输序列中的轮次，即我们再次看到，即使它是唯一一个有帧要发送的节点。</p>
  </li>
</ul>

<h5 id="频分多路复用fdm">频分多路复用（FDM）：</h5>

<p>FDM将R bps信道划分为不同的频段(每个频段具有R/N带宽)，并把每个频率分配给N个节点中的一个。因此FDM在单个较大的R bps信道中创建了N个较小的R/N bps信道。FDM也有TDM同样的优点和缺点。它避免了碰撞，在N个节点之间公平地划分了带宽。然而，FDM也有TDM所具有的主要缺点，也就是限制一个节点只能使用R/N的带宽，即使当它是唯一一个有分组要发送的节点时。</p>

<h5 id="码分多址cdma">码分多址（CDMA）：</h5>

<p>CDMA对每个节点分配一种不同的编码。然后每个节点用它唯一的编码来对它发送的数据进行编码如果精心选择这些编码，CDMA网络具有一种奇妙的特性，即不同的节点能够同时传输，并且它们各自相应的接收方仍能正确接 收发送方编码的数据比特(假设接收方知道发送方的编码)，而不在乎其他节点的干扰传输。</p>

<h4 id="随机访问random-accessmac协议">随机访问(random access)MAC协议</h4>

<ul>
  <li>信道不划分，允许冲突</li>
  <li>采用冲突“恢复”机制</li>
</ul>

<p>在随机接入协议中，一个传输节点总是以信道的全部速率R(即Kbps)进行发送。当有碰撞时，涉及碰撞的每个节点反复地重发它的帧 (也就是分组)，到该帧无碰撞地通过为止。但是当一个节点经历一次碰撞时，它不必立刻重发该帧。相反，它在重发该帧之前等待一个随机时延。涉及碰撞的每个节点独立地选择随机时延。因为该随机时延是独立地选择的，所以下述现象是有可能的：这些节点之一所选择的时延充分小于其他碰撞节点的时延，并因此能够无碰撞地将它的帧在信道中发出。</p>

<h5 id="时隙aloha协议">时隙ALOHA协议</h5>

<ul>
  <li>当节点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传输整个帧。</li>
  <li>如果没有碰撞，该节点成功地传输它的帧，从而不需要考虑重传该帧。(如果该节点有新帧，它能够为传输准备一个新帧。)</li>
  <li>如果有碰撞，该节点在时隙结束之前检测到这次碰撞。该节点以概率P在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。</li>
</ul>

<p>我们说以概率P重传，是指某节点有效地投掷一个有偏倚的硬币;硬币正面事件对 应着重传，而重传出现的概率为”硬币反面事件对应着“跳过这个时隙，在下个时隙再掷硬币”；这个事件以概率(1 - P)出现。所有涉及碰撞的节点独立地投掷它们的硬币。</p>

<p>优点：</p>

<ul>
  <li>
    <p>当某节点时唯一活跃的节点时，时隙ALOHA允许该节点以全速R连续传输。</p>
  </li>
  <li>时隙ALOHA也是高度发散的，因为每个节点检测碰撞并独立的决定什么时候重传。</li>
  <li>时隙ALOHA是一个简单的协议。</li>
</ul>

<p>考虑效率：</p>

<p>时隙多路访问协议的效率：当有大量的活跃节点且每个 节点总有大量的帧要发送时，长期运行中成功时隙的份额。注意到如果不使用某种形式的访问控制，而且每个节点都在每次碰撞之后立即重传，这个效率将为零。</p>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjM1MTU5Mw==,size_16,color_FFFFFF,t_70#pic_center-1705419257478-3.jpeg" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5SajgKuX-1617844005122)(/Users/mac/Desktop/计算机网络/blog/第6章 链路层和局域网/13.jpg)]" /></p>

<p>一个给定节点成功传送的概率是$p(1-p)^{N-1}$，N个节点成功传送的概率是$Np(1-p)^{N-1}$。</p>

<p>然后，当N趋近与无穷时，我们会发现这个协议的最大效率为1/e=0.37。这就是说，当有大量节点有很多帧要传输时，则(最多)仅有37%的时隙做有用的工作。<strong>因此该信道有效传输速率不是R bps,而仅为0.37R bps</strong>！相似的分析还表明37%的时隙是空闲的，26%的时隙有碰撞。试想一个蹩脚的网络管理员购买了一个100Mbps的时隙ALOHA系统，希望能够使用网络在大量的用户之间以总计速率如80Mbps来传输数据。尽管这个信道能够以信道的全速100Mbps传输一个给定的帧，但从长时间范围看，该信道的成功吞吐量将小于37Mbps。</p>

<h5 id="纯aloha协议">纯ALOHA协议</h5>

<p>时隙ALOHA协议要求所有的节点同步它们的传输，以在每个时隙开始时开始传输。 第一个ALOHA协议实际上是一个非时隙、完全分散的协议。在纯ALOHA中，当一帧首次到达(即一个网络层数据报在发送节点从网络层传递下来)，节点立刻将该帧完整地传输进广播信道。</p>

<p>如果一个传输的帧与一个或多个传输经历了碰撞，这个节点将立即(在完全传输完它的碰撞帧之后)以概率P重传该帧。</p>

<p>否则，该节点等待一个帧传输时间。在此等待之后，它则以概率P传输该帧，或者以概率1 - P在另一个帧时间等待(保持空闲)。</p>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjM1MTU5Mw==,size_16,color_FFFFFF,t_70#pic_center-1705419697443-6.jpeg" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xCSKu4gw-1617844005123)(/Users/mac/Desktop/计算机网络/blog/第6章 链路层和局域网/14.jpg)]" /></p>

<p>为了确定纯ALOHA的最大效率，我们关注某个单独的节点。我们的假设与在时隙ALOHA分析中所做的相同，取帧传输时间为时间单元。在任何给定时间，某节点传输一个帧的概率是处假设该帧在时刻S开始传输。为了使该帧能成功地传输，在时间间隔[t0-1, t0]，中不能有其他节点开始传输。这种传输将与节点i的帧传输起始部分相重叠。所有其他节点在这个时间间隔不开始传输的概率是(1-P)N-1。类似地，当节点i在传输时，其他节点不能开始传输，因为这种传输将与节点i传输的后面部分相重叠。所有其他节点在这个时间间隔不开始传输的概率也是(1-P)N-1。因此，一个给定的节点成功传输一次的概率是P(1-P)2(N-1)。通过与时隙ALOHA情况一样来取极限，<strong>我们求得纯ALOHA协议的最大效率仅为1/(2e)，这刚好是时隙ALOHA的一半。这就是完全分散的ALOHA协议所要付出的代价。</strong></p>

<p><img src="/assets/计算机网络.assets/image-20240116235112791.png" alt="image-20240116235112791" /></p>

<h5 id="载波侦听多路访问csma">载波侦听多路访问（CSMA）</h5>

<p>载波侦听（carrier sensing）：一个节点在传输前先听信道。如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输。</p>

<p><strong>规则：</strong></p>

<ul>
  <li>说之前先听听，有别人说话你就别说了，没人说了你再说。这就是<strong>载波侦听</strong>，即一个节点在传输前先听信道，如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输。</li>
  <li>如果你说的同时别人也在说，就别说了。这就是<strong>碰撞检测</strong>，即当一个传输节点在传输时一直在侦听此信道。如果它检测到另一个节点正在传输干扰帧，它就停止传输，在重复“侦听-当空闲时传输”循环之前等待一段随机时间。</li>
</ul>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjM1MTU5Mw==,size_16,color_FFFFFF,t_70#pic_center-1705420324778-9.jpeg" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-D2Bl07RS-1617844005124)(/Users/mac/Desktop/计算机网络/blog/第6章 链路层和局域网/15.jpg)]" /></p>

<p>在t0时刻，节点B侦听到信道是空闲的，因为当前没有其他节点在传输。因此节点B开始传输，沿着广播媒体在两个方向上传播它的比特。比特随着时间的增加向下传播，这表明B的比特沿着广播媒体传播所实际需要的时间不是零(虽然以接近光的速度)。在时刻t1，节点D有一个帧要发送。尽管节点B在时刻t1正在传输，但B传输的比特还没有到达D，因此D在t1侦听到信道空闲。根据CSMA协议，从而D开始传输它的帧。一个短暂的时间之后，B的传输开始在D干扰D的传输。显然广播信道的端到端信道传播时延(channel propagation delay)(信号从一个节点传播到另一个节点所花费的时间)在决定其性能方面起着关键的作用。该传播时延越长，载波侦听节点不能侦听到网络中另一个节点已经开始传输的机会就越大。</p>

<p>这样依旧会造成碰撞，因为即使现在检测到信道口没有使用，可是一旦开始传输数据，其他传播过来的数据可能刚好到达，这样也会造成碰撞。所有，如果检测到两个节点同时开始传输，则应立即停止传输，在下次传输之前等待一个随机时间</p>

<h5 id="具有碰撞检测的载波侦听多路访问csmacd">具有碰撞检测的载波侦听多路访问（CSMA/CD）</h5>

<p>碰撞检测（collision detection）：当一个传输节点在传输时一直在侦听此信道。如果它检测到另一个节点正在传输干扰帧，<strong>它就会停止传输</strong>，在重复”侦听-当空闲时传输“循环之前等待一段<strong>随机时间</strong>。</p>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjM1MTU5Mw==,size_16,color_FFFFFF,t_70#pic_center-1705421031327-12.jpeg" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Zylpvk4L-1617844005125)(/Users/mac/Desktop/计算机网络/blog/第6章 链路层和局域网/16.jpg)]" /></p>

<p>当某节点执行碰撞检测时，一旦它检测到碰撞将立即停止传输。</p>

<p>注意等待的随机时间：用于以太网以及DOCSIS电缆网络多路访问协议中用二进制指数后退算法。</p>

<p>CSMA/CD效率：</p>

<p><img src="/assets/计算机网络.assets/20210408091122407.jpeg" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FL2aeSZh-1617844005126)(/Users/mac/Desktop/计算机网络/blog/第6章 链路层和局域网/17.jpg)]" /></p>

<p>如果传播时延为0，碰撞的节点将立即终止而不会浪费。</p>

<p>如果一个帧取得了信道时，它将占有信道很长时间，因此信道在大多数时间都会有效地工作。</p>

<h5 id="二进制指数类型退避算法">二进制指数类型退避算法</h5>

<p>发生碰撞的站在停止发送数据后，要推迟(退避)一个随机时间才能再发送数据</p>

<ol>
  <li>
    <p>基本退避时间取为争用期 2z</p>
  </li>
  <li>从整数集合 [0，1，·.·，(2* - 1)] 中随机地取出一个数，记为 r。重传所
的时延就<strong>是r倍的基本退避时间</strong>。</li>
  <li>参数 k 按下面的公式计算:
k = Min[重传次数，10]</li>
  <li>当 k &lt;10 时，参数 k 等于重传次数。</li>
  <li>当重传达 16 次仍不能成功时即丢弃该，并向高层报告</li>
</ol>

<blockquote>
  <p>例如:
第 1次冲突重传时
k = 1，r 为 {0，1}集合中的任何一个数。
第 2次冲突重传时:
k = 2，r 为 {0，1，2，3} 集合中的任何一个数。
第 3 次冲突重传时:
k = 3，r 为{0，1，2，3，4，5，6，7}集合中的任何一个数。</p>
</blockquote>

<h5 id="最小帧长问题">最小帧长问题</h5>

<p><img src="/assets/计算机网络.assets/image-20240117091636408.png" alt="image-20240117091636408" /></p>

<p><strong>例题：</strong></p>

<p><img src="/assets/计算机网络.assets/image-20240117091808010.png" alt="image-20240117091808010" /></p>

<h4 id="轮转taking-turnsmac协议">轮转(“taking turns)MAC协议</h4>

<ul>
  <li>结点轮流使用信道</li>
</ul>

<p>前面讲过多路访问协议的两个理想特性是：</p>

<ol>
  <li>当只有一个节点活跃吋，该活跃节点具 有R bps的吞吐量；</li>
  <li>当有M个节点活跃时，每个活跃节点的吞吐量接近R/M bps。</li>
</ol>

<p>ALOHA和CSMA协议具备第一个特性，但不具备第二个特性。这激发研究人员创造另一类协议，也就是轮流协议(taking- turns protocol)。</p>

<p><strong>轮询协议</strong>
轮询协议要求这些节点之一要被指定为主节点。主节点以循环的方式轮询(poll)每个节点。特别是，主节点首先向节点1发送一个报文，告诉它(节点1) 能够传输的帧的最多数量。在节点1传输了某些帧后，主节点告诉节点2它(节点2)能够传输的帧的最多数量。(主节点能够通过观察在信道上是否缺乏信号，来决定一个节点何时完成了帧的发送。)上述过程以这种方式继续进行，主节点以循环的方式轮询了每个节点。</p>

<p>轮询协议消除了困扰随机接入协议的碰撞和空时隙，这使得轮询取得高得多的效率。但是它也有一些缺点。</p>

<p>第一个缺点是该协议引入了轮询时延，即通知一个节点“它可以传输”所需的时间。例如，如果只有一个节点是活跃的，那么这个节点将以小于R bps的速率传输，因为每次活跃节点发送了它最多数量的帧时，主节点必须依次轮询每一个非活跃的节点。
第二个缺点（单点故障）可能更为严重，就是如果主节点有故障，整个信道都变得不可操作。
<strong>令牌传递协议</strong>
在这种协议中没有主节点。一个称为令牌(token) 的小的特殊帧在节点之间以某种固定的次序进行交换。</p>

<p>例如，节点1可能总是把令牌发送给节点2 ,节点2可能总是把令牌发送给节点3，而节点N可能总是把令牌发送给节点1。当一个节点收到令牌时，仅当它有一些帧要发送时，它才持有这个令牌；否则，它立即向下一个节点转发该令牌。当一个节点收到令牌时，如果它确实有帧要传输，它发送最大数目的帧数，然后把令牌转发给下一个节点。令牌传递是分散的，并有很高的效率。</p>

<p>但是它也有自己的一些问题。例如，一个节点的故障可能会使整个信道崩溃。或者如果一个节点偶然忘记了释放令牌，则必须调用某些恢复步骤使令牌返回到循环中来。</p>

<h3 id="交换局域网">交换局域网</h3>

<h4 id="mac地址">MAC地址</h4>

<p>事实上并不是主机或者路由器具有链路层地址，而是适配器（网络接口）具有链路层地址。所以有多个接口的主机或者路由器将会有多个链路层地址。链路层交换机并不具备与它们的接口（这些接口是与主机和路由器相连的）相关联的链路层地址。</p>

<p>MAC地址也叫LAN地址或者物理地址，对于大多数局域网（包括以太网和802.11无线局域网）MAC地址长度6字节，共有2^48个可能的MAC地址。通常采用16进制表示法，每个字节一对16进制数。尽管MAC地址是永久的，但是用软件改变一个MAC地址被认为是可能的。</p>

<p>没有两块适配器具有相同的MAC地址。适配器的MAC地址具有扁平结构（与层次结构相反），而且适配器地址不会随着位置的改变而变化。IP地址具有层次结构（一个网络部分和一个主机部分），主机移动时，IP地址也会改变。IP地址类似于人的邮政地址，搬家了就变了，MAC地址类似于人的身份证号。</p>

<p>某适配器向某目的适配器发送一个帧时会把目的适配器的MAC地址插入到帧中，一<strong>台交换机偶尔会把一个帧广播到所有数据接口，因此一个适配器可以接收一个并非向它寻址的帧。</strong>所有当一个适配器收到一个帧时，就检查帧中的目的MAC地址是不是跟自己的一样，一样就提取出数据报并沿着协议栈向上传递，不一样就扔了。有时也会发送帧要求局域网中的所有其他适配器来处理这个帧，这时候填入一个特殊的MAC广播地址（FF-FF-FF-FF-FF-FF）。</p>

<h3 id="地址解析协议">地址解析协议</h3>

<p>因为存在链路层地址（即MAC地址）和网络层地址（例如IP地址，因为网络层还具有除了IP之外的其他协议，如果使用IP地址寻址而不是MAC的话，那么适配器将不能方便的支持其他网络层协议工作，这也是MAC地址存在的原因之一），<strong>而且还需要在它们之间进行相互转换，所以就有了地址解析协议（ARP）</strong>。另外，本节假设交换机广播所有帧。为了发送数据报，源要向它的适配器不仅提供IP数据报还要提供目的主机的IP地址，这就用到了ARP。在发送主机中的ARP模块将取在相同局域网上的任何IP地址作为输入，然后返回响应的MAC地址，这和DNS类似，但不同的是，DNS为在因特网中的任何位置的主机解析主机名，<strong>而ARP只为在同一个子网的主机和路由器接口解析IP地址</strong>，否则将返回错误。</p>

<p>每台路由器或主机在内存中维护一个ARP表，包含了MAC地址和IP地址的映射关系，也包含一个寿命值（TTL），它指示了从表中删除某个映射的时间。</p>

<p>如果发送端维护的ARP表中没有目的IP地址对应的MAC地址怎么办呢<strong>？发送方用ARP协议来解析这个地址也就是发送一个ARP分组，包括源和目的IP地址和MAC地址，查询分组和响应分组都具有相应的格式，查询分组的目的是询问子网上的所有其他主机和路由器。发送方会使用广播地址（FF-FF-FF-FF-FF-FF）来发送分组，适配器在链路层帧中封装这个分组并传输进子网中。</strong>联系之前的类比，就好像在一个拥挤的房间大喊：邮政地址是xxx的那个人的身份证号是多少？子网中的每个适配器都会收到这个帧并且向上传递给ARP模块，查询之后与之IP匹配的就发送一个ARP响应分组回去，里面当然包括了它的MAC地址，这时候之前的查询主机就能更新它的ARP表，并且继续之后的发送工作。</p>

<h4 id="arp协议">ARP协议</h4>

<p>ARP:地址解析协议（Address Resolution Protocol）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>基本功能：知道目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。
它是IPv4中网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。
12
</code></pre></div></div>

<h4 id="arp报文格式">ARP报文格式</h4>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODY2ODEw,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>先要清楚，一般说以太网地址就是指MAC地址。

　　字段1是ARP请求的目的以太网地址，全1时代表广播地址。

　　字段2是发送ARP请求的以太网地址。

　　字段3以太网帧类型表示的是后面的数据类型，ARP请求和ARP应答这个值为0x0806。

　　字段4表示硬件地址的类型，硬件地址不只以太网一种，是以太网类型时此值为1。

　　字段5表示要映射的协议地址的类型，要对IPv4地址进行映射，此值为0x0800。

　　字段6和7表示硬件地址长度和协议地址长度，MAC地址占6字节，IP地址占4字节。

　　字段8是操作类型字段，值为1，表示进行ARP请求；值为2，表示进行ARP应答；值为3，表示进行RARP请求；值为4，表示进行RARP应答。

　　字段9是发送端ARP请求或应答的硬件地址，这里是以太网地址，和字段2相同。

　　字段10是发送ARP请求或应答的IP地址。

　　字段11和12是目的端的硬件地址和协议地址。
123456789101112131415161718192021
</code></pre></div></div>

<h4 id="apr工作过程">APR工作过程</h4>

<p>如图所示：
<img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODY2ODEw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" /></p>

<p>假设主机A和B在同一个网段，主机A要向主机B发送信息，具体的地址解析过程如下：</p>

<p>(1) 主机A首先查看自己的ARP表，如果ARP表中含有主机B对应的ARP表项，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。</p>

<p>(2) 如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。</p>

<p>(3) 主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。</p>

<p>(4) 主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</p>

<h4 id="发送数据报到子网以外">发送数据报到子网以外</h4>

<p>当子网中的某主机要向子网之外的主机发送网络层数据报的情况。</p>

<p><img src="/assets/计算机网络.assets/20210408091242943.jpg" alt="20210408091242943" /></p>

<p>我们发现为了使一个数据报从111.111.111.111到子网2上的主机，该数据报必须首先发送给路由器接口 111.111.111.110，它是通往最终目的地路径上的第一跳路由器的IP地址。因此，对于该帧来说，适当的MAC地址是路由器接口111. 111. 111. 110的适配器地址，即E6- E9-00- 17-BB-4BO但发送主机怎样获得 111.111.111.110的MAC地址呢？当然是通过使用ARP!</p>

<p>一旦发送适配器有了这个MAC地址，它创建一个帧(包含了寻址到222. 222. 222. 222的数据报)，并把该帧发送到子网1中。在子网1上的路由器适配器看到该链路层帧是向它寻址的，因此把这个帧传递给路由器的网络层。万岁!该IP数据报终于被成功地从源主机移动到这台路由器了！但是我们的任务还没有结束。我们仍然要将该数据报从路由器移动到目的地。路由器现在必须决定该数据报要被转发的正确接口。这是通过查询路由器中的转发表来完成的。转发表告诉这台路由器该数据报要通过路由器接口 222. 222. 222. 220转发。然后该接口把这个数据报传递给它的适配器，适配器把该数据报封装到一个新的帧中，并且将帧发送进子网2 中。这时，该帧的目的MAC地址确实是最终目的地MAC地址。路由器又是怎样获得这个目的地MAC地址的呢？当然是用ARP获得的！</p>

<h3 id="以太网">以太网</h3>

<p>以太网:不可靠、无连接服务</p>

<ul>
  <li>无连接(connectionless): 发送的网卡与接收帧的网卡间没有“握手”过程</li>
  <li>不可靠(unreliable): 接收网卡不向发送网卡进行确认</li>
  <li>差错帧直接丢弃，丢弃帧中的数据恢复依靠高层协议 (e.g.，TCP)，否则，发生数据丢失</li>
  <li>以太网的MAC协议:采用二进制指数退避算法的CSMA/CD</li>
</ul>

<p>在 IP 数据包交付的过程中，在数据链路层会对数据包进行添加报头信息。以太网协议就是数据链路层的一个重要协议。这样说其实不太准确，因为以太网协议是一个规定数据链路层及物理层的协议，不能说它是数据链路层的一个协议。
以太网几乎占领着现有的有线局域网市场。</p>

<p>以太网具有二进制指数回退的CSMA/CD多路访问协议。</p>

<h4 id="以太网帧结构">以太网帧结构：</h4>

<p><img src="/assets/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjM1MTU5Mw==,size_16,color_FFFFFF,t_70#pic_center-1705456337171-16.jpeg" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-KF6XkP8h-1617844005133)(/Users/mac/Desktop/计算机网络/blog/第6章 链路层和局域网/23.jpg)]" /></p>

<ul>
  <li>
    <p>数据字段（46~1500字节）。这个字段承载了IP数据报。以太网的最大传输单元(MTU)是1500字节。这意味着如果IP数据报超过了1500字节，则主机必须将该数据报分片。数据字段的最小长度是46字节。这意味着如果IP数据报小于46字节，数据报必须被填充到46字节。当采用填充时，传递到网络层的数据包括IP数据报和填充部分。网络层使用IP数据报首部中的长度字段来去除填充部分。</p>
  </li>
  <li>目的地址（6字节）。这个字段包含目的适配器的MAC地址，当目的适配器收到一个以太网帧，帧的目的地址无论是该适配器的MAC地址，还是MAC广播地址，它都将该帧的数据字段的内容传递给网络层；如果它收到了具有任何其他MAC地址的帧，则丢弃之。</li>
  <li>源地址（6字节）。这个字段包含了传输该帧到局域网上的适配器的MAC地址。</li>
  <li>类型字段（2字节）。类型字段允许以太网复用多种网络层协议。为了理解这点, 我们需要记住主机能够使用除了IP以外的其他网络层协议。事实上，一台给定的主机可以支持多种网络层协议，以对不同的应用采用不同的协议。</li>
  <li>CRC（4字节）。检测帧中是否引入了差错。</li>
  <li>前同步码（8字节）。<strong>以太网帧以一个8字节的前同步码(Preamble)字段开始。该前同步码的前7字节的值都是10101010；最后一个字节是10101011</strong>。前同步码字段的前7 字节用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步。为什么这些时钟会不同步呢？记住适配器A的目的是根据以太局域网类型的不同，分别以10Mbps、100Mbps或者lGbps的速率传输帧。然而，没有什么是完美无缺的，因此适配器A不会以精确的额定速率传输帧；相对于额定速率总有一 些漂移，局域网上的其他适配器不会预先知道这种漂移的。接收适配器只需通过锁定前同步码的前7字节的比特，就能够锁定适配器A的时钟。前同步码的第8 个字节的最后两个比特(第一个出现的两个连续的1)警告适配器B， “重要的内容”就要到来了。</li>
</ul>

<p>所有的以太网技术都向网络层提供无连接服务。这就是说，当适配器A要向适配器B发送一个数据报时，适配器A在一个以太网帧中封装该数据报，并且把该帧发送到局域网上，没有先与适配器B握手。这种第二层的无连接服务类似于IP的第三层数据报服务和UDP的第四层无连接服务。</p>

<p>以太网技术都向网络层提供不可靠服务。特别是，当适配器B收到一个来自适配器A的帧，它对该帧执行CRC校验，但是当该帧通过CRC校验时它既不发送确认帧；而当该帧没有通过CRC校验时它也不发送否定确认帧。当某帧没有通过CRC校验，适配器B只是丢弃该帧。因此，适配器A根本不知道它传输的帧是否到达了B并通过了CRC校验。(在链路层)缺乏可靠的传输有助于使得以太网简单和便宜。但是它也意味着传递到网络层的数据报流能够有间隙。</p>

<p>如果由于丢弃了以太网帧而存在间隙，主机B上的应用也会看见这个间隙吗？这只取决于该应用是使用UDP还是使用TCP。<strong>如果应用使用的是UDP，则主机B中的应用的确会看到数据中的间隙。另一方面，如果应用使用的是TCP， 则主机B中的TCP将不会确认包含在丢弃帧中的数据，</strong>从而引起主机A的TCP重传。注意到当TCP重传数据时，数据最终将回到曾经丢弃它的以太网适配器。因此，从这种意义上来说，以太网的确重传了数据，尽管以太网并不知道它是正在传输一个具有全新数据的全新数据报，还是一个包含已经被传输过至少一次的数据的数据报。</p>
</div><section class="article__sharing d-print-none"></section><div class="d-print-none"><footer class="article__footer"><meta itemprop="dateModified" content="2023-12-05T00:00:00+08:00"><!-- start custom article footer snippet -->

<!-- end custom article footer snippet -->
<div class="article__subscribe"><div class="subscribe"><i class="fas fa-rss"></i> <a type="application/rss+xml" href="/feed.xml">订阅</a></div>
</div><div class="article__license"><div class="license">
    <p>本文遵守 <a itemprop="license" rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">Attribution-NonCommercial 4.0 International</a> 许可协议。
      <a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">
        <img alt="Attribution-NonCommercial 4.0 International" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" />
      </a>
    </p>
  </div></div></footer>
<div class="article__section-navigator clearfix"><div class="previous"><span>上篇</span><a href="/2023/12/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E5%BC%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0.html">机器学习导引笔记</a></div><div class="next"><span>下篇</span><a href="/2023/12/06/%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%92%8C%E5%BE%AE%E6%9C%BA%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.html">接口技术和微机技术笔记</a></div></div></div>

</div>

<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    $(function() {
      var $this ,$scroll;
      var $articleContent = $('.js-article-content');
      var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
      var scroll = hasSidebar ? '.js-page-main' : 'html, body';
      $scroll = $(scroll);

      $articleContent.find('.highlight').each(function() {
        $this = $(this);
        $this.attr('data-lang', $this.find('code').attr('data-lang'));
      });
      $articleContent.find('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]').each(function() {
        $this = $(this);
        $this.append($('<a class="anchor d-print-none" aria-hidden="true"></a>').html('<i class="fas fa-anchor"></i>'));
      });
      $articleContent.on('click', '.anchor', function() {
        $scroll.scrollToAnchor('#' + $(this).parent().attr('id'), 400);
      });
    });
  });
})();
</script>
</div><section class="page__comments d-print-none"><div id="vcomments"></div><script>
  window.Lazyload.js(['//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js', 'https://unpkg.com/valine/dist/Valine.min.js'], function() {
    var _config = {
      el: '#vcomments',
      appId:  'ONcOJaEzueQcEXVrHVv5dQ4F-gzGzoHsz',
      appKey: '0iORBozCMxniZ0spe5QY9zCO',
      verify: true,
    };_config.lang = 'en';new Valine(_config);
  });
</script></section></article><!-- start custom main bottom snippet -->

<!-- end custom main bottom snippet -->
</div>
            </div></div></div><div class="page__footer d-print-none">
<footer class="footer py-4 js-page-footer">
  <div class="main"><div itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xingjie Gao"><meta itemprop="url" content="/"><meta itemprop="description" content="To be a question, to be an answer."><div class="footer__author-links"><div class="author-links">
  <ul class="menu menu--nowrap menu--inline"><li title="给我发邮件。">
      <a class="button button--circle mail-button" itemprop="email" href="mailto:xingjie-gao@outlook.com" target="_blank">
        <i class="fas fa-envelope"></i>
      </a><li title="在 Github 上关注我。">
        <a class="button button--circle github-button" itemprop="sameAs" href="https://github.com/Kfkcome" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path class="svgpath" data-index="path_0" fill="#272636" d="M0 525.2c0 223.6 143.3 413.7 343 483.5 26.9 6.8 22.8-12.4 22.8-25.4l0-88.7c-155.3 18.2-161.5-84.6-172-101.7-21.1-36-70.8-45.2-56-62.3 35.4-18.2 71.4 4.6 113.1 66.3 30.2 44.7 89.1 37.2 119 29.7 6.5-26.9 20.5-50.9 39.7-69.6C248.8 728.2 181.7 630 181.7 513.2c0-56.6 18.7-108.7 55.3-150.7-23.3-69.3 2.2-128.5 5.6-137.3 66.5-6 135.5 47.6 140.9 51.8 37.8-10.2 80.9-15.6 129.1-15.6 48.5 0 91.8 5.6 129.8 15.9 12.9-9.8 77-55.8 138.8-50.2 3.3 8.8 28.2 66.7 6.3 135 37.1 42.1 56 94.6 56 151.4 0 117-67.5 215.3-228.8 243.7 26.9 26.6 43.6 63.4 43.6 104.2l0 128.8c0.9 10.3 0 20.5 17.2 20.5C878.1 942.4 1024 750.9 1024 525.3c0-282.9-229.3-512-512-512C229.1 13.2 0 242.3 0 525.2L0 525.2z" />
</svg>
</div>
        </a>
      </li></ul>
</div>
</div>
    </div><div class="site-info mt-2">
      <div>© Ennis's Blog 2021,
        Powered by <a title="Jekyll is a simple, blog-aware, static site generator." href="http://jekyllrb.com/">Jekyll</a> & <a
        title="TeXt is a super customizable Jekyll theme." href="https://github.com/kitian616/jekyll-TeXt-theme">TeXt Theme</a>.
      </div>
    </div>
  </div>
</footer>
</div></div>
    </div><script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $body = $('body'), $window = $(window);
    var $pageRoot = $('.js-page-root'), $pageMain = $('.js-page-main');
    var activeCount = 0;
    function modal(options) {
      var $root = this, visible, onChange, hideWhenWindowScroll = false;
      var scrollTop;
      function setOptions(options) {
        var _options = options || {};
        visible = _options.initialVisible === undefined ? false : show;
        onChange = _options.onChange;
        hideWhenWindowScroll = _options.hideWhenWindowScroll;
      }
      function init() {
        setState(visible);
      }
      function setState(isShow) {
        if (isShow === visible) {
          return;
        }
        visible = isShow;
        if (visible) {
          activeCount++;
          scrollTop = $(window).scrollTop() || $pageMain.scrollTop();
          $root.addClass('modal--show');
          $pageMain.scrollTop(scrollTop);
          activeCount === 1 && ($pageRoot.addClass('show-modal'), $body.addClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.on('scroll', hide);
          $window.on('keyup', handleKeyup);
        } else {
          activeCount > 0 && activeCount--;
          $root.removeClass('modal--show');
          $window.scrollTop(scrollTop);
          activeCount === 0 && ($pageRoot.removeClass('show-modal'), $body.removeClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.off('scroll', hide);
          $window.off('keyup', handleKeyup);
        }
        onChange && onChange(visible);
      }
      function show() {
        setState(true);
      }
      function hide() {
        setState(false);
      }
      function handleKeyup(e) {
        // Char Code: 27  ESC
        if (e.which ===  27) {
          hide();
        }
      }
      setOptions(options);
      init();
      return {
        show: show,
        hide: hide,
        $el: $root
      };
    }
    $.fn.modal = modal;
  });
})();
</script><div class="modal modal--overflow page__search-modal d-print-none js-page-search-modal"><script>
(function () {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    // search panel
    var search = (window.search || (window.search = {}));
    var useDefaultSearchBox = window.useDefaultSearchBox === undefined ?
      true : window.useDefaultSearchBox ;

    var $searchModal = $('.js-page-search-modal');
    var $searchToggle = $('.js-search-toggle');
    var searchModal = $searchModal.modal({ onChange: handleModalChange, hideWhenWindowScroll: true });
    var modalVisible = false;
    search.searchModal = searchModal;

    var $searchBox = null;
    var $searchInput = null;
    var $searchClear = null;

    function getModalVisible() {
      return modalVisible;
    }
    search.getModalVisible = getModalVisible;

    function handleModalChange(visible) {
      modalVisible = visible;
      if (visible) {
        search.onShow && search.onShow();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].focus();
      } else {
        search.onShow && search.onHide();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].blur();
        setTimeout(function() {
          useDefaultSearchBox && ($searchInput.val(''), $searchBox.removeClass('not-empty'));
          search.clear && search.clear();
          window.pageAsideAffix && window.pageAsideAffix.refresh();
        }, 400);
      }
    }

    $searchToggle.on('click', function() {
      modalVisible ? searchModal.hide() : searchModal.show();
    });
    // Char Code: 83  S, 191 /
    $(window).on('keyup', function(e) {
      if (!modalVisible && !window.isFormElement(e.target || e.srcElement) && (e.which === 83 || e.which === 191)) {
        modalVisible || searchModal.show();
      }
    });

    if (useDefaultSearchBox) {
      $searchBox = $('.js-search-box');
      $searchInput = $searchBox.children('input');
      $searchClear = $searchBox.children('.js-icon-clear');
      search.getSearchInput = function() {
        return $searchInput.get(0);
      };
      search.getVal = function() {
        return $searchInput.val();
      };
      search.setVal = function(val) {
        $searchInput.val(val);
      };

      $searchInput.on('focus', function() {
        $(this).addClass('focus');
      });
      $searchInput.on('blur', function() {
        $(this).removeClass('focus');
      });
      $searchInput.on('input', window.throttle(function() {
        var val = $(this).val();
        if (val === '' || typeof val !== 'string') {
          search.clear && search.clear();
        } else {
          $searchBox.addClass('not-empty');
          search.onInputNotEmpty && search.onInputNotEmpty(val);
        }
      }, 400));
      $searchClear.on('click', function() {
        $searchInput.val(''); $searchBox.removeClass('not-empty');
        search.clear && search.clear();
      });
    }
  });
})();
</script><div class="search search--dark">
  <div class="main">
    <div class="search__header">搜索</div>
    <div class="search-bar">
      <div class="search-box js-search-box">
        <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
        <input type="text" />
        <div class="search-box__icon-clear js-icon-clear">
          <a><i class="fas fa-times"></i></a>
        </div>
      </div>
      <button class="button button--theme-dark button--pill search__cancel js-search-toggle">
        取消</button>
    </div>
    <div class="search-result js-search-result"></div>
  </div>
</div>
<script>var SOURCES = window.TEXT_VARIABLES.sources;
var PAHTS = window.TEXT_VARIABLES.paths;
window.Lazyload.js([SOURCES.jquery, PAHTS.search_js], function() {
  var search = (window.search || (window.search = {}));
  var searchData = window.TEXT_SEARCH_DATA || {};

  function memorize(f) {
    var cache = {};
    return function () {
      var key = Array.prototype.join.call(arguments, ',');
      if (key in cache) return cache[key];
      else return cache[key] = f.apply(this, arguments);
    };
  }

  /// search
  function searchByQuery(query) {
    var i, j, key, keys, cur, _title, result = {};
    keys = Object.keys(searchData);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < searchData[key].length; j++) {
        cur = searchData[key][j], _title = cur.title;
        if ((result[key] === undefined || result[key] && result[key].length < 4 )
          && _title.toLowerCase().indexOf(query.toLowerCase()) >= 0) {
          if (result[key] === undefined) {
            result[key] = [];
          }
          result[key].push(cur);
        }
      }
    }
    return result;
  }

  var renderHeader = memorize(function(header) {
    return $('<p class="search-result__header">' + header + '</p>');
  });

  var renderItem = function(index, title, url) {
    return $('<li class="search-result__item" data-index="' + index + '"><a class="button" href="' + url + '">' + title + '</a></li>');
  };

  function render(data) {
    if (!data) { return null; }
    var $root = $('<ul></ul>'), i, j, key, keys, cur, itemIndex = 0;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      $root.append(renderHeader(key));
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        $root.append(renderItem(itemIndex++, cur.title, cur.url));
      }
    }
    return $root;
  }

  // search box
  var $result = $('.js-search-result'), $resultItems;
  var lastActiveIndex, activeIndex;

  function clear() {
    $result.html(null);
    $resultItems = $('.search-result__item'); activeIndex = 0;
  }
  function onInputNotEmpty(val) {
    $result.html(render(searchByQuery(val)));
    $resultItems = $('.search-result__item'); activeIndex = 0;
    $resultItems.eq(0).addClass('active');
  }

  search.clear = clear;
  search.onInputNotEmpty = onInputNotEmpty;

  function updateResultItems() {
    lastActiveIndex >= 0 && $resultItems.eq(lastActiveIndex).removeClass('active');
    activeIndex >= 0 && $resultItems.eq(activeIndex).addClass('active');
  }

  function moveActiveIndex(direction) {
    var itemsCount = $resultItems ? $resultItems.length : 0;
    if (itemsCount > 1) {
      lastActiveIndex = activeIndex;
      if (direction === 'up') {
        activeIndex = (activeIndex - 1 + itemsCount) % itemsCount;
      } else if (direction === 'down') {
        activeIndex = (activeIndex + 1 + itemsCount) % itemsCount;
      }
      updateResultItems();
    }
  }

  // Char Code: 13  Enter, 37  ⬅, 38  ⬆, 39  ➡, 40  ⬇
  $(window).on('keyup', function(e) {
    var modalVisible = search.getModalVisible && search.getModalVisible();
    if (modalVisible) {
      if (e.which === 38) {
        modalVisible && moveActiveIndex('up');
      } else if (e.which === 40) {
        modalVisible && moveActiveIndex('down');
      } else if (e.which === 13) {
        modalVisible && $resultItems && activeIndex >= 0 && $resultItems.eq(activeIndex).children('a')[0].click();
      }
    }
  });

  $result.on('mouseover', '.search-result__item > a', function() {
    var itemIndex = $(this).parent().data('index');
    itemIndex >= 0 && (lastActiveIndex = activeIndex, activeIndex = itemIndex, updateResultItems());
  });
});
</script>
</div></div>


<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function scrollToAnchor(anchor, duration, callback) {
      var $root = this;
      $root.animate({ scrollTop: $(anchor).position().top }, duration, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
    $.fn.scrollToAnchor = scrollToAnchor;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function affix(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroll,
        offsetBottom = 0, scrollTarget = window, scroll = window.document, disabled = false, isOverallScroller = true,
        rootTop, rootLeft, rootHeight, scrollBottom, rootBottomTop,
        hasInit = false, curState;

      function setOptions(options) {
        var _options = options || {};
        _options.offsetBottom && (offsetBottom = _options.offsetBottom);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroll && (scroll = _options.scroll);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $scrollTarget = $(scrollTarget);
        isOverallScroller = window.isOverallScroller($scrollTarget[0]);
        $scroll = $(scroll);
      }
      function preCalc() {
        top();
        rootHeight = $root.outerHeight();
        rootTop = $root.offset().top + (isOverallScroller ? 0 :  $scrollTarget.scrollTop());
        rootLeft = $root.offset().left;
      }
      function calc(needPreCalc) {
        needPreCalc && preCalc();
        scrollBottom = $scroll.outerHeight() - offsetBottom - rootHeight;
        rootBottomTop = scrollBottom - rootTop;
      }
      function top() {
        if (curState !== 'top') {
          $root.removeClass('fixed').css({
            left: 0,
            top: 0
          });
          curState = 'top';
        }
      }
      function fixed() {
        if (curState !== 'fixed') {
          $root.addClass('fixed').css({
            left: rootLeft + 'px',
            top: 0
          });
          curState = 'fixed';
        }
      }
      function bottom() {
        if (curState !== 'bottom') {
          $root.removeClass('fixed').css({
            left: 0,
            top: rootBottomTop + 'px'
          });
          curState = 'bottom';
        }
      }
      function setState() {
        var scrollTop = $scrollTarget.scrollTop();
        if (scrollTop >= rootTop && scrollTop <= scrollBottom) {
          fixed();
        } else if (scrollTop < rootTop) {
          top();
        } else {
          bottom();
        }
      }
      function init() {
        if(!hasInit) {
          var interval, timeout;
          calc(true); setState();
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState();
          });
          $window.on('resize', function() {
            disabled || (calc(true), setState());
          });
          hasInit = true;
        }
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions,
        refresh: function() {
          calc(true, { animation: false }); setState();
        }
      };
    }
    $.fn.affix = affix;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function toc(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroller, $tocUl = $('<ul class="toc toc--ellipsis"></ul>'), $tocLi, $headings, $activeLast, $activeCur,
        selectors = 'h1,h2,h3', container = 'body', scrollTarget = window, scroller = 'html, body', disabled = false,
        headingsPos, scrolling = false, hasRendered = false, hasInit = false;

      function setOptions(options) {
        var _options = options || {};
        _options.selectors && (selectors = _options.selectors);
        _options.container && (container = _options.container);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroller && (scroller = _options.scroller);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $headings = $(container).find(selectors).filter('[id]');
        $scrollTarget = $(scrollTarget);
        $scroller = $(scroller);
      }
      function calc() {
        headingsPos = [];
        $headings.each(function() {
          headingsPos.push(Math.floor($(this).position().top));
        });
      }
      function setState(element, disabled) {
        var scrollTop = $scrollTarget.scrollTop(), i;
        if (disabled || !headingsPos || headingsPos.length < 1) { return; }
        if (element) {
          $activeCur = element;
        } else {
          for (i = 0; i < headingsPos.length; i++) {
            if (scrollTop >= headingsPos[i]) {
              $activeCur = $tocLi.eq(i);
            } else {
              $activeCur || ($activeCur = $tocLi.eq(i));
              break;
            }
          }
        }
        $activeLast && $activeLast.removeClass('active');
        ($activeLast = $activeCur).addClass('active');
      }
      function render() {
        if(!hasRendered) {
          $root.append($tocUl);
          $headings.each(function() {
            var $this = $(this);
            $tocUl.append($('<li></li>').addClass('toc-' + $this.prop('tagName').toLowerCase())
              .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
          });
          $tocLi = $tocUl.children('li');
          $tocUl.on('click', 'a', function(e) {
            e.preventDefault();
            var $this = $(this);
            scrolling = true;
            setState($this.parent());
            $scroller.scrollToAnchor($this.attr('href'), 400, function() {
              scrolling = false;
            });
          });
        }
        hasRendered = true;
      }
      function init() {
        var interval, timeout;
        if(!hasInit) {
          render(); calc(); setState(null, scrolling);
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState(null, scrolling);
          });
          $window.on('resize', window.throttle(function() {
            if (!disabled) {
              render(); calc(); setState(null, scrolling);
            }
          }, 100));
        }
        hasInit = true;
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions
      };
    }
    $.fn.toc = toc;
  });
})();
/*(function () {

})();*/
</script><script>
  /* toc must before affix, since affix need to konw toc' height. */(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  var TOC_SELECTOR = window.TEXT_VARIABLES.site.toc.selectors;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window);
    var $articleContent = $('.js-article-content');
    var $tocRoot = $('.js-toc-root'), $col2 = $('.js-col-aside');
    var toc;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
    var hasToc = $articleContent.find(TOC_SELECTOR).length > 0;

    function disabled() {
      return $col2.css('display') === 'none' || !hasToc;
    }

    tocDisabled = disabled();

    toc = $tocRoot.toc({
      selectors: TOC_SELECTOR,
      container: $articleContent,
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      tocDisabled = disabled();
      toc && toc.setOptions({
        disabled: tocDisabled
      });
    }, 100));

  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $pageFooter = $('.js-page-footer');
    var $pageAside = $('.js-page-aside');
    var affix;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');

    affix = $pageAside.affix({
      offsetBottom: $pageFooter.outerHeight(),
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      scroll: hasSidebar ? $('.js-page-main').children() : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      affix && affix.setOptions({
        disabled: tocDisabled
      });
    }, 100));

    window.pageAsideAffix = affix;
  });
})();
</script><script>
  window.Lazyload.js(['https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js', 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js'], function() {
    var $canvas = null, $this = null, _ctx = null, _text = '';
    $('.language-chart').each(function(){
      $this = $(this);
      $canvas = $('<canvas></canvas>');
      _text = $this.text();
      $this.text('').append($canvas);
      _ctx = $canvas.get(0).getContext('2d');
      (_ctx && _text) && (new Chart(_ctx, JSON.parse(_text)) && $this.attr('data-processed', true));
    });
  });
</script>
<script type="text/x-mathjax-config">
	var _config = { tex2jax: {
		inlineMath: [['$','$'], ['\\(','\\)']]
	}};_config.TeX = { equationNumbers: { autoNumber: "all" } };MathJax.Hub.Config(_config);
</script>
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  window.Lazyload.js('https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js', function() {
    mermaid.initialize({
      startOnLoad: true
    });
    mermaid.init(undefined, '.language-mermaid');
  });
</script>
<script>(function() {
  function errorHandler(error, callback) {
    if (error) {
      callback && callback(error);
      throw error;
    }
  }

  function pageview(_AV, options) {
    var AV = _AV;
    var appId, appKey, appClass;
    appId = options.appId;
    appKey = options.appKey;
    appClass = options.appClass;
    if (!AV.applicationId) {
      AV.init({
        serverURLs: 'https://avoscloud.com',
        appId: appId,
        appKey: appKey
      });
    } else {
      console.log('LeanCloud SDK 已经初始化过了。');
    }
    return {
      get: get,
      increase: increase
    };

    function searchKey(key) {
      var query = new AV.Query(appClass);
      query.equalTo('key', key);
      return query.first();
    }

    function insert(key, title) {
      var Blog = AV.Object.extend(appClass);
      var blog = new Blog();
      blog.set('title', title);
      blog.set('key', key);
      blog.set('views', 0);
      return blog.save();
    }

    function increment(result) {
      result.increment('views', 1);
      return result.save(null, {
        fetchWhenSave: true
      });
    }

    function get(key, callback) {
      searchKey(key).then(function(result) {
        if (result) {
          callback && callback(result.attributes.views);
        }
      }, errorHandler);
    }

    function increase(key, title, callback) {
      searchKey(key).then(function(result) {
        if (result) {
          increment(result).then(function(result) {
            callback && callback(result.attributes.views);
          });
        } else {
          insert(key, title).then(function(result) {
            increment(result).then(function(result) {
              callback && callback(result.attributes.views);
            });
          }, errorHandler);
        }
      }, errorHandler);
    }
  }
  window.pageview = pageview;
})();
</script>
  <script>
    window.Lazyload.js(['https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js', '//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js'], function() {
      var pageview = window.pageview(AV, {
        appId:    'ONcOJaEzueQcEXVrHVv5dQ4F-gzGzoHsz',
        appKey:   '0iORBozCMxniZ0spe5QY9zCO',
        appClass: 'Test'
      });
      var key =   'post24';
      var title = "计算机网络笔记";
      pageview.increase(key, title, function(view) {
        $("[data-page-key='post24']").text(view);
      });
    });
  </script>
    </div>
    <script>(function () {
  var $root = document.getElementsByClassName('root')[0];
  if (window.hasEvent('touchstart')) {
    $root.dataset.isTouch = true;
    document.addEventListener('touchstart', function(){}, false);
  }
})();
</script>
  </body>
</html>

